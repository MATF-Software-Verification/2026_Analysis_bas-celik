
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>card: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ubavic/bas-celik/v2/card/apdu.go (97.6%)</option>
				
				<option value="file1">github.com/ubavic/bas-celik/v2/card/apollo.go (0.0%)</option>
				
				<option value="file2">github.com/ubavic/bas-celik/v2/card/atr.go (100.0%)</option>
				
				<option value="file3">github.com/ubavic/bas-celik/v2/card/ber/ber.go (30.3%)</option>
				
				<option value="file4">github.com/ubavic/bas-celik/v2/card/card.go (8.6%)</option>
				
				<option value="file5">github.com/ubavic/bas-celik/v2/card/gemalto.go (0.0%)</option>
				
				<option value="file6">github.com/ubavic/bas-celik/v2/card/idCard.go (0.0%)</option>
				
				<option value="file7">github.com/ubavic/bas-celik/v2/card/medical.go (4.1%)</option>
				
				<option value="file8">github.com/ubavic/bas-celik/v2/card/pin.go (100.0%)</option>
				
				<option value="file9">github.com/ubavic/bas-celik/v2/card/smartCard.go (0.0%)</option>
				
				<option value="file10">github.com/ubavic/bas-celik/v2/card/state.go (0.0%)</option>
				
				<option value="file11">github.com/ubavic/bas-celik/v2/card/tlv/tlv.go (100.0%)</option>
				
				<option value="file12">github.com/ubavic/bas-celik/v2/card/unknownCard.go (0.0%)</option>
				
				<option value="file13">github.com/ubavic/bas-celik/v2/card/vehicle.go (10.6%)</option>
				
				<option value="file14">github.com/ubavic/bas-celik/v2/document/document.go (100.0%)</option>
				
				<option value="file15">github.com/ubavic/bas-celik/v2/document/excel.go (0.0%)</option>
				
				<option value="file16">github.com/ubavic/bas-celik/v2/document/id.go (67.4%)</option>
				
				<option value="file17">github.com/ubavic/bas-celik/v2/document/idPrint.go (36.1%)</option>
				
				<option value="file18">github.com/ubavic/bas-celik/v2/document/medical.go (78.4%)</option>
				
				<option value="file19">github.com/ubavic/bas-celik/v2/document/vehicle.go (86.2%)</option>
				
				<option value="file20">github.com/ubavic/bas-celik/v2/internal/flags.go (0.0%)</option>
				
				<option value="file21">github.com/ubavic/bas-celik/v2/internal/gui/about.go (0.0%)</option>
				
				<option value="file22">github.com/ubavic/bas-celik/v2/internal/gui/cardReaderUI.go (0.0%)</option>
				
				<option value="file23">github.com/ubavic/bas-celik/v2/internal/gui/celiktheme/theme.go (0.0%)</option>
				
				<option value="file24">github.com/ubavic/bas-celik/v2/internal/gui/crypto.go (0.0%)</option>
				
				<option value="file25">github.com/ubavic/bas-celik/v2/internal/gui/document.go (0.0%)</option>
				
				<option value="file26">github.com/ubavic/bas-celik/v2/internal/gui/icon/icon.go (0.0%)</option>
				
				<option value="file27">github.com/ubavic/bas-celik/v2/internal/gui/pinChange.go (0.0%)</option>
				
				<option value="file28">github.com/ubavic/bas-celik/v2/internal/gui/poller.go (0.0%)</option>
				
				<option value="file29">github.com/ubavic/bas-celik/v2/internal/gui/preferences.go (0.0%)</option>
				
				<option value="file30">github.com/ubavic/bas-celik/v2/internal/gui/reader/linux.go (0.0%)</option>
				
				<option value="file31">github.com/ubavic/bas-celik/v2/internal/gui/reader/poller.go (0.0%)</option>
				
				<option value="file32">github.com/ubavic/bas-celik/v2/internal/gui/save.go (0.0%)</option>
				
				<option value="file33">github.com/ubavic/bas-celik/v2/internal/gui/smartbox.go (0.0%)</option>
				
				<option value="file34">github.com/ubavic/bas-celik/v2/internal/gui/translate.go (0.0%)</option>
				
				<option value="file35">github.com/ubavic/bas-celik/v2/internal/gui/translation/translation.go (0.0%)</option>
				
				<option value="file36">github.com/ubavic/bas-celik/v2/internal/gui/ui.go (0.0%)</option>
				
				<option value="file37">github.com/ubavic/bas-celik/v2/internal/gui/widgets/clipboard.go (0.0%)</option>
				
				<option value="file38">github.com/ubavic/bas-celik/v2/internal/gui/widgets/field.go (0.0%)</option>
				
				<option value="file39">github.com/ubavic/bas-celik/v2/internal/gui/widgets/group.go (0.0%)</option>
				
				<option value="file40">github.com/ubavic/bas-celik/v2/internal/gui/widgets/spacer.go (0.0%)</option>
				
				<option value="file41">github.com/ubavic/bas-celik/v2/internal/gui/widgets/startPage.go (0.0%)</option>
				
				<option value="file42">github.com/ubavic/bas-celik/v2/internal/gui/widgets/statusBar.go (0.0%)</option>
				
				<option value="file43">github.com/ubavic/bas-celik/v2/internal/gui/widgets/toolbar.go (0.0%)</option>
				
				<option value="file44">github.com/ubavic/bas-celik/v2/internal/logger/log.go (0.0%)</option>
				
				<option value="file45">github.com/ubavic/bas-celik/v2/internal/read.go (0.0%)</option>
				
				<option value="file46">github.com/ubavic/bas-celik/v2/internal/runGUI.go (0.0%)</option>
				
				<option value="file47">github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11/externalModule.go (0.0%)</option>
				
				<option value="file48">github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11/vendor.go (0.0%)</option>
				
				<option value="file49">github.com/ubavic/bas-celik/v2/internal/smartbox/server/getCertificates.go (0.0%)</option>
				
				<option value="file50">github.com/ubavic/bas-celik/v2/internal/smartbox/server/getInfo.go (0.0%)</option>
				
				<option value="file51">github.com/ubavic/bas-celik/v2/internal/smartbox/server/getProviders.go (0.0%)</option>
				
				<option value="file52">github.com/ubavic/bas-celik/v2/internal/smartbox/server/getSignedXml.go (0.0%)</option>
				
				<option value="file53">github.com/ubavic/bas-celik/v2/internal/smartbox/server/getTerminals.go (0.0%)</option>
				
				<option value="file54">github.com/ubavic/bas-celik/v2/internal/smartbox/server/onOpen.go (0.0%)</option>
				
				<option value="file55">github.com/ubavic/bas-celik/v2/internal/smartbox/server/server.go (0.0%)</option>
				
				<option value="file56">github.com/ubavic/bas-celik/v2/internal/smartbox/server/session.go (0.0%)</option>
				
				<option value="file57">github.com/ubavic/bas-celik/v2/internal/smartbox/server/start.go (0.0%)</option>
				
				<option value="file58">github.com/ubavic/bas-celik/v2/internal/smartbox/server/stringOrInt.go (0.0%)</option>
				
				<option value="file59">github.com/ubavic/bas-celik/v2/localization/format.go (100.0%)</option>
				
				<option value="file60">github.com/ubavic/bas-celik/v2/localization/scripts.go (100.0%)</option>
				
				<option value="file61">github.com/ubavic/bas-celik/v2/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package card

import "fmt"

// Constructs an APDU (Application Protocol Data Unit) command according
// to the specifications from the ISO 7816-4 (5. Organization for interchange).
func buildAPDU(cla, ins, p1, p2 byte, data []byte, ne uint) []byte <span class="cov8" title="1">{
        length := len(data)

        if length &gt; 0xFFFF </span><span class="cov0" title="0">{
                panic(fmt.Errorf("APDU command length too large"))</span>
        }

        <span class="cov8" title="1">apdu := make([]byte, 4)
        apdu[0] = cla
        apdu[1] = ins
        apdu[2] = p1
        apdu[3] = p2

        if length == 0 </span><span class="cov8" title="1">{
                if ne != 0 </span><span class="cov8" title="1">{
                        if ne &lt;= 256 </span><span class="cov8" title="1">{
                                l := byte(0x00)
                                if ne != 256 </span><span class="cov8" title="1">{
                                        l = byte(ne)
                                }</span>
                                <span class="cov8" title="1">apdu = append(apdu, l)</span>
                        } else<span class="cov8" title="1"> {
                                var l1, l2 byte
                                if ne == 65536 </span><span class="cov8" title="1">{
                                        l1 = 0
                                        l2 = 0
                                }</span> else<span class="cov8" title="1"> {
                                        l1 = byte(ne &gt;&gt; 8)
                                        l2 = byte(ne)
                                }</span>
                                <span class="cov8" title="1">apdu = append(apdu, []byte{l1, l2}...)</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                if ne == 0 </span><span class="cov8" title="1">{
                        if length &lt;= 255 </span><span class="cov8" title="1">{
                                apdu = append(apdu, byte(length))
                                apdu = append(apdu, data...)
                        }</span> else<span class="cov8" title="1"> {
                                l := []byte{0x0, byte(length &gt;&gt; 8), byte(length)}
                                apdu = append(apdu, l...)
                                apdu = append(apdu, data...)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if length &lt;= 255 &amp;&amp; ne &lt;= 256 </span><span class="cov8" title="1">{
                                apdu = append(apdu, byte(length))
                                apdu = append(apdu, data...)
                                if ne != 256 </span><span class="cov8" title="1">{
                                        apdu = append(apdu, byte(ne))
                                }</span> else<span class="cov8" title="1"> {
                                        apdu = append(apdu, 0x00)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                l := []byte{0x00, byte(length &gt;&gt; 8), byte(length)}
                                apdu = append(apdu, l...)
                                apdu = append(apdu, data...)
                                if ne != 65536 </span><span class="cov8" title="1">{
                                        neB := []byte{byte(ne &gt;&gt; 8), byte(ne)}
                                        apdu = append(apdu, neB...)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return apdu</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package card

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"

        "github.com/ubavic/bas-celik/v2/document"
)

// Apollo is the type of the first smart ID cards.
// Apollo cards are not manufactured anymore, and this code could be removed in the future.
type Apollo struct {
        atr           Atr
        smartCard     Card
        documentFile  []byte
        personalFile  []byte
        residenceFile []byte
        photoFile     []byte
}

var APOLLO_ATR = Atr([]byte{
        0x3B, 0xB9, 0x18, 0x00, 0x81, 0x31, 0xFE, 0x9E, 0x80,
        0x73, 0xFF, 0x61, 0x40, 0x83, 0x00, 0x00, 0x00, 0xDF,
})

func (card *Apollo) InitCard() error <span class="cov0" title="0">{
        return nil
}</span>

func (card *Apollo) ReadCard() error <span class="cov0" title="0">{

        var err error

        card.documentFile, err = card.ReadFile(ID_DOCUMENT_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading document file: %w", err)
        }</span>

        <span class="cov0" title="0">card.personalFile, err = card.ReadFile(ID_PERSONAL_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading personal file: %w", err)
        }</span>

        <span class="cov0" title="0">card.residenceFile, err = card.ReadFile(ID_RESIDENCE_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading residence file: %w", err)
        }</span>

        <span class="cov0" title="0">rsp, err := card.ReadFile(ID_PHOTO_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading photo file: %w", err)
        }</span>

        <span class="cov0" title="0">card.photoFile = trim4b(rsp)

        return nil</span>
}

func (card *Apollo) GetDocument() (document.Document, error) <span class="cov0" title="0">{
        doc := document.IdDocument{}

        err := parseIdDocumentFile(card.documentFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing document file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseIdPersonalFile(card.personalFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing personal file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseIdResidenceFile(card.residenceFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing residence file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseAndAssignIdPhotoFile(card.photoFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing photo file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

func (card *Apollo) Atr() Atr <span class="cov0" title="0">{
        return card.atr
}</span>

func (card *Apollo) ReadFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        output := make([]byte, 0)

        _, err := card.selectFile(name, 4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := read(card.smartCard, 0, 6)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading file header: %w", err)
        }</span>

        <span class="cov0" title="0">if len(data) &lt; 5 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file too short")
        }</span>
        <span class="cov0" title="0">length := uint(binary.LittleEndian.Uint16(data[4:]))
        offset := uint(6)

        for length &gt; 0 </span><span class="cov0" title="0">{
                data, err := read(card.smartCard, offset, length)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reading file: %w", err)
                }</span>

                <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">output = append(output, data...)

                offset += uint(len(data))
                length -= uint(len(data))</span>
        }

        <span class="cov0" title="0">return output, nil</span>
}

func (card *Apollo) Test() bool <span class="cov0" title="0">{
        return true
}</span>

func (card *Apollo) selectFile(name []byte, ne uint) ([]byte, error) <span class="cov0" title="0">{
        apu := buildAPDU(0x00, 0xA4, 0x08, 0x00, name, ne)
        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file %s: %w", hex.EncodeToString(name), err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file %s: response %s", hex.EncodeToString(name), hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">return rsp, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package card

import (
        "encoding/hex"
        "slices"
)

type Atr []byte

func (atr Atr) String() string <span class="cov8" title="1">{
        return hex.EncodeToString([]byte(atr))
}</span>

func (atr Atr) Is(otherAtr Atr) bool <span class="cov8" title="1">{
        return slices.Equal(atr, otherAtr)
}</span>

func DetectCardDocumentByAtr(atr Atr) []CardDocumentType <span class="cov8" title="1">{
        if atr.Is(GEMALTO_ATR_1) </span><span class="cov8" title="1">{
                return []CardDocumentType{GemaltoIdDocumentCardType, VehicleDocumentCardType}
        }</span> else<span class="cov8" title="1"> if atr.Is(GEMALTO_ATR_2) || atr.Is(GEMALTO_ATR_3) </span><span class="cov8" title="1">{
                return []CardDocumentType{GemaltoIdDocumentCardType, MedicalDocumentCardType, VehicleDocumentCardType}
        }</span> else<span class="cov8" title="1"> if atr.Is(GEMALTO_ATR_4) </span><span class="cov8" title="1">{
                return []CardDocumentType{GemaltoIdDocumentCardType, VehicleDocumentCardType}
        }</span> else<span class="cov8" title="1"> if atr.Is(MEDICAL_ATR_1) || atr.Is(MEDICAL_ATR_2) </span><span class="cov8" title="1">{
                return []CardDocumentType{MedicalDocumentCardType}
        }</span> else<span class="cov8" title="1"> if atr.Is(VEHICLE_ATR_0) || atr.Is(VEHICLE_ATR_2) || atr.Is(VEHICLE_ATR_3) || atr.Is(VEHICLE_ATR_4) </span><span class="cov8" title="1">{
                return []CardDocumentType{VehicleDocumentCardType}
        }</span> else<span class="cov8" title="1"> if atr.Is(APOLLO_ATR) </span><span class="cov8" title="1">{
                return []CardDocumentType{ApolloIdDocumentCardType}
        }</span> else<span class="cov8" title="1"> {
                return []CardDocumentType{UnknownDocumentCardType}
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ber

import (
        "encoding/binary"
        "errors"
        "fmt"
        "strings"

        "github.com/ubavic/bas-celik/v2/card/cardErrors"
)

// Represents a node (or a tree) of a BER structure.
// Each leaf node contains data, and it is considered 'primitive'.
// Non-leaf nodes don't contain any data, but they contain references to child nodes.
type BER struct {
        tag       uint32 // Complete tag of a node.
        primitive bool   // Denotes if node is a leaf.
        data      []byte // Data of leaf node. Should only exist if primitive is true.
        children  []BER  // Branch nodes children. Should only exist if primitive is false.
}

// Parses BER data (described in ISO/IEC 7816-4 (2005)).
func ParseBER(data []byte) (*BER, error) <span class="cov0" title="0">{
        primitive, constructed, err := parseBERLayer(data)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ber := BER{
                tag:       0,
                primitive: false,
                data:      nil,
                children:  []BER{},
        }

        for t, v := range primitive </span><span class="cov0" title="0">{
                val := BER{
                        tag:       t,
                        primitive: true,
                        data:      v,
                        children:  nil,
                }

                err = ber.add(val)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("adding primitive value: %w", err)
                }</span>
        }

        <span class="cov0" title="0">for t, v := range constructed </span><span class="cov0" title="0">{
                subBer, err := ParseBER(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">val := BER{
                        tag:       t,
                        primitive: false,
                        data:      nil,
                        children:  subBer.children,
                }

                err = ber.add(val)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("adding primitive value: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;ber, nil</span>

}

// Access node's data with the provided address composed as a list of tags.
func (tree BER) access(address ...uint32) ([]byte, error) <span class="cov0" title="0">{
        if len(address) == 0 </span><span class="cov0" title="0">{
                return tree.data, nil
        }</span> else<span class="cov0" title="0"> {
                var found *BER = nil
                for i := range tree.children </span><span class="cov0" title="0">{
                        if tree.children[i].tag == address[0] </span><span class="cov0" title="0">{
                                found = &amp;tree.children[i]
                                break</span>
                        }
                }
                <span class="cov0" title="0">if found != nil </span><span class="cov0" title="0">{
                        return found.access(address[1:]...)
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("tag not found")
                }</span>
        }
}

// Recursively inserts a new node (with all children nodes) into BER tree. It doesn't copy data.
// If a node with the same tag and the type (primitive/constructed) already exists in tree, then procedure continues
// inserting in deeper levels. If a node with the same tag and different type already exists, function return error.
func (into *BER) add(new BER) error <span class="cov0" title="0">{
        if into.primitive </span><span class="cov0" title="0">{
                return errors.New("can't add a value into primitive value")
        }</span>

        <span class="cov0" title="0">var targetField *BER

        alreadyExists := false
        for i := range into.children </span><span class="cov0" title="0">{
                if into.children[i].tag == new.tag </span><span class="cov0" title="0">{
                        alreadyExists = true
                        targetField = &amp;into.children[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if !alreadyExists </span><span class="cov0" title="0">{
                into.children = append(into.children, new)
                return nil
        }</span> else<span class="cov0" title="0"> {
                if targetField.primitive == new.primitive </span><span class="cov0" title="0">{
                        if targetField.primitive </span><span class="cov0" title="0">{
                                *targetField = new
                        }</span> else<span class="cov0" title="0"> {
                                for i := range new.children </span><span class="cov0" title="0">{
                                        err := targetField.add(new.children[i])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        return errors.New("types don't match")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Merge two BER trees by adding all nodes of the second tree into the first tree.
// Doesn't copy an data.+
func (into *BER) Merge(new BER) error <span class="cov0" title="0">{
        if into.tag != new.tag </span><span class="cov0" title="0">{
                return errors.New("tags don't match")
        }</span>

        <span class="cov0" title="0">for _, c := range new.children </span><span class="cov0" title="0">{
                if err := into.add(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Parses one level of BER-TLV encoded data.
// Returns map of primitive and constructed fields.
func parseBERLayer(data []byte) (map[uint32][]byte, map[uint32][]byte, error) <span class="cov0" title="0">{
        primF := make(map[uint32][]byte)
        consF := make(map[uint32][]byte)
        offset := uint32(0)

        for </span><span class="cov0" title="0">{
                tag, primitive, offsetDelta, err := ParseTag(data[offset:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("parsing BER record tag: %w", err)
                }</span>

                <span class="cov0" title="0">offset += offsetDelta

                length, offsetDelta, err := ParseLength(data[offset:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("parsing BER record length: %w", err)
                }</span>

                <span class="cov0" title="0">if uint32(len(data)) &lt;= offset+length </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("parsing BER record data: %w", cardErrors.ErrInvalidLength)
                }</span>

                <span class="cov0" title="0">offset += offsetDelta
                value := data[offset : offset+length]

                if primitive </span><span class="cov0" title="0">{
                        primF[tag] = value
                }</span> else<span class="cov0" title="0"> {
                        consF[tag] = value
                }</span>

                <span class="cov0" title="0">offset += length

                if offset == uint32(len(data)) </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if offset &gt; uint32(len(data)) </span><span class="cov0" title="0">{
                        return nil, nil, cardErrors.ErrInvalidLength
                }</span>
        }

        <span class="cov0" title="0">return primF, consF, nil</span>
}

func (tree *BER) AssignFrom(target *string, address ...uint32) <span class="cov0" title="0">{
        bytes, err := tree.access(address...)
        if err == nil </span><span class="cov0" title="0">{
                *target = string(bytes)
        }</span>
}

// Flattens a BER tree into list of strings. Used for printing.
func (tree *BER) levels() []string <span class="cov0" title="0">{
        if tree.primitive </span><span class="cov0" title="0">{
                return []string{fmt.Sprintf("%X: %s", tree.tag, string(tree.data))}
        }</span> else<span class="cov0" title="0"> {
                strings := []string{fmt.Sprint(tree.tag) + ":"}
                for _, child := range tree.children </span><span class="cov0" title="0">{
                        childrenStrings := child.levels()
                        for i := range childrenStrings </span><span class="cov0" title="0">{
                                childrenStrings[i] = "  " + childrenStrings[i]
                        }</span>
                        <span class="cov0" title="0">strings = append(strings, childrenStrings...)</span>
                }

                <span class="cov0" title="0">return strings</span>
        }
}

// Flattens a BER tree into single string. Each line represents single node of a tree.
func (tree BER) String() string <span class="cov0" title="0">{
        return strings.Join(tree.levels(), "\n")
}</span>

// Parses length of a field according to specification given in ISO 7816-4 (5. Organization for interchange).
// Returns parsed length, number of parsed bytes and possible error.
func ParseLength(data []byte) (uint32, uint32, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return 0, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">firstByte := uint32(data[0])
        var offset, length uint32
        if firstByte &lt; 0x80 </span><span class="cov8" title="1">{
                length = uint32(data[0])
                offset = 1
        }</span> else<span class="cov8" title="1"> if firstByte == 0x80 </span><span class="cov8" title="1">{
                return 0, 0, cardErrors.ErrInvalidFormat
        }</span> else<span class="cov8" title="1"> if firstByte == 0x81 &amp;&amp; len(data) &gt;= 2 </span><span class="cov8" title="1">{
                length = uint32(data[1])
                offset = 2
        }</span> else<span class="cov8" title="1"> if firstByte == 0x82 &amp;&amp; len(data) &gt;= 3 </span><span class="cov8" title="1">{
                length = uint32(binary.BigEndian.Uint16(data[1:]))
                offset = 3
        }</span> else<span class="cov8" title="1"> if firstByte == 0x83 &amp;&amp; len(data) &gt;= 4 </span><span class="cov8" title="1">{
                length = 0x00FFFFFF &amp; binary.BigEndian.Uint32(data)
                offset = 4
        }</span> else<span class="cov8" title="1"> if firstByte == 0x84 &amp;&amp; len(data) &gt;= 5 </span><span class="cov8" title="1">{
                length = binary.BigEndian.Uint32(data[1:])
                offset = 5
        }</span> else<span class="cov8" title="1"> {
                return 0, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">return length, offset, nil</span>
}

// Parses tag of a field according to specification given in ISO 7816-4 (5. Organization for interchange).
// Returns parsed tag, primitive flag, number of parsed bytes and possible error.
func ParseTag(data []byte) (uint32, bool, uint32, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return 0, false, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">primitive := true
        if data[0]&amp;0b100000 != 0 </span><span class="cov8" title="1">{
                primitive = false
        }</span>

        <span class="cov8" title="1">var tag, offset uint32
        if 0x1F&amp;data[0] != 0x1F </span><span class="cov8" title="1">{
                tag = uint32(data[0])
                offset = 1
        }</span> else<span class="cov8" title="1"> if len(data) &gt;= 2 &amp;&amp; data[1]&amp;0x80 == 0x00 </span><span class="cov8" title="1">{
                tag = uint32(binary.BigEndian.Uint16(data))
                offset = 2
        }</span> else<span class="cov8" title="1"> if len(data) &gt;= 3 </span><span class="cov8" title="1">{
                tag = uint32(data[0])&lt;&lt;16 | uint32(data[1])&lt;&lt;8 | uint32(data[2])
                offset = 3
        }</span> else<span class="cov8" title="1"> {
                return 0, false, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">return tag, primitive, offset, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package card provides functions for communication with smart cards.
// It includes implementations for handling different types of smart cards
// and reading associated documents.
package card

import (
        "errors"
        "fmt"
        "slices"

        "github.com/ebfe/scard"
        doc "github.com/ubavic/bas-celik/v2/document"
)

// Represents a physical or virtual smart card.
// Essentially it is just a wrapper for the scard.Card type,
// but it also allows virtual cards which can be useful for testing.
type Card interface {
        Status() (*scard.CardStatus, error)
        Transmit([]byte) ([]byte, error)
        BeginTransaction() error
        EndTransaction(scard.Disposition) error
}

// Represents a smart card with a document.
// All types of documents that Bas Celik can read should satisfy this interface
type CardDocument interface {
        ReadFile([]byte) ([]byte, error)
        InitCard() error
        ReadCard() error
        GetDocument() (doc.Document, error)
        Test() bool
        Atr() Atr
}

// Represents a different types of smart card documents.
// Each value of `CardDocumentType` is represented with a struct
// that satisfies `CardDocument` interface.
type CardDocumentType uint8

const (
        UnknownDocumentCardType = CardDocumentType(iota)
        ApolloIdDocumentCardType
        GemaltoIdDocumentCardType
        MedicalDocumentCardType
        VehicleDocumentCardType
)

var ErrUnknownCard = errors.New("unknown card")

// Detects Card Document from card's ATR
// Ambiguous cases are solved by reading specific card content
func DetectCardDocument(sc Card) (CardDocument, error) <span class="cov0" title="0">{
        smartCardStatus, err := sc.Status()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading card status %w", err)
        }</span>

        <span class="cov0" title="0">atr := Atr(smartCardStatus.Atr)

        possibleCardTypes := DetectCardDocumentByAtr(atr)

        for _, cardType := range possibleCardTypes </span><span class="cov0" title="0">{
                switch cardType </span>{
                case ApolloIdDocumentCardType:<span class="cov0" title="0">
                        card := &amp;Apollo{atr: atr, smartCard: sc}
                        return card, nil</span>
                case GemaltoIdDocumentCardType:<span class="cov0" title="0">
                        card := Gemalto{atr: atr, smartCard: sc}
                        if card.Test() </span><span class="cov0" title="0">{
                                return &amp;card, nil
                        }</span>
                case VehicleDocumentCardType:<span class="cov0" title="0">
                        card := VehicleCard{atr: atr, smartCard: sc}
                        if card.Test() </span><span class="cov0" title="0">{
                                return &amp;card, nil
                        }</span>
                case MedicalDocumentCardType:<span class="cov0" title="0">
                        card := MedicalCard{atr: atr, smartCard: sc}
                        if card.Test() </span><span class="cov0" title="0">{
                                return &amp;card, nil
                        }</span>
                default:<span class="cov0" title="0">
                        card := &amp;UnknownDocumentCard{atr: atr, smartCard: sc}
                        return card, ErrUnknownCard</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected card type (ATR: %s)", atr)</span>
}

// Reads binary data from the card starting from the specified offset and with the specified length.
func read(card Card, offset, length uint) ([]byte, error) <span class="cov0" title="0">{
        readSize := min(length, 0xFF)
        apu := buildAPDU(0x00, 0xB0, byte((0xFF00&amp;offset)&gt;&gt;8), byte(offset&amp;0xFF), nil, readSize)
        rsp, err := card.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading binary: %w", err)
        }</span>

        <span class="cov0" title="0">if len(rsp) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading binary: bad status code")
        }</span>

        <span class="cov0" title="0">return rsp[:len(rsp)-2], nil</span>
}

// Checks if the card response indicates no error.
func responseOK(rsp []byte) bool <span class="cov8" title="1">{
        if len(rsp) &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return slices.Equal(rsp[len(rsp)-2:], []byte{0x90, 0x00})</span>
}

// Trim four bytes from the start of the slice
func trim4b(data []byte) []byte <span class="cov0" title="0">{
        if len(data) &gt; 4 </span><span class="cov0" title="0">{
                return data[4:]
        }</span>

        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package card

import (
        "bytes"
        "compress/zlib"
        "crypto/x509"
        "encoding/binary"
        "encoding/hex"
        "errors"
        "fmt"
        "io"

        "github.com/ebfe/scard"
        "github.com/ubavic/bas-celik/v2/document"
)

var GEMALTO_ATR_1 = Atr([]byte{
        0x3B, 0xFF, 0x94, 0x00, 0x00, 0x81, 0x31, 0x80,
        0x43, 0x80, 0x31, 0x80, 0x65, 0xB0, 0x85, 0x02,
        0x01, 0xF3, 0x12, 0x0F, 0xFF, 0x82, 0x90, 0x00,
        0x79,
})

// Available since January 2023 (maybe). Replaced very soon with an even newer version.
var GEMALTO_ATR_2 = Atr([]byte{
        0x3B, 0xF9, 0x96, 0x00, 0x00, 0x80, 0x31, 0xFE,
        0x45, 0x53, 0x43, 0x45, 0x37, 0x20, 0x47, 0x43,
        0x4E, 0x33, 0x5E,
})

// Available since July 2023.
var GEMALTO_ATR_3 = Atr([]byte{
        0x3B, 0x9E, 0x96, 0x80, 0x31, 0xFE, 0x45, 0x53,
        0x43, 0x45, 0x20, 0x38, 0x2E, 0x30, 0x2D, 0x43,
        0x31, 0x56, 0x30, 0x0D, 0x0A, 0x6F,
})

// Available since June 2024.
var GEMALTO_ATR_4 = Atr([]byte{
        0x3B, 0x9E, 0x96, 0x80, 0x31, 0xFE, 0x45, 0x53,
        0x43, 0x45, 0x20, 0x38, 0x2E, 0x30, 0x2D, 0x43,
        0x32, 0x56, 0x30, 0x0D, 0x0A, 0x6C,
})

// Gemalto represents ID cards based with Gemalto Java OS. Gemalto replaced Apollo cards around 2014.
type Gemalto struct {
        atr           Atr
        smartCard     Card
        documentFile  []byte
        personalFile  []byte
        residenceFile []byte
        photoFile     []byte
        signature     [2][]byte
        certificates  []*x509.Certificate
}

func (card *Gemalto) InitCard() error <span class="cov0" title="0">{
        data := []byte{0xF3, 0x81, 0x00, 0x00, 0x02, 0x53, 0x45, 0x52, 0x49, 0x44, 0x01}
        apu := buildAPDU(0x00, 0xA4, 0x04, 0x00, data, 0)
        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initializing ID card: %w", err)
        }</span>

        <span class="cov0" title="0">if responseOK(rsp) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data = []byte{0xF3, 0x81, 0x00, 0x00, 0x02, 0x53, 0x45, 0x52, 0x49, 0x46, 0x01}
        apu = buildAPDU(0x00, 0xA4, 0x04, 0x00, data, 0)
        rsp, err = card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initializing IF card: %w", err)
        }</span>

        <span class="cov0" title="0">if responseOK(rsp) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data = []byte{0xF3, 0x81, 0x00, 0x00, 0x02, 0x53, 0x45, 0x52, 0x52, 0x50, 0x01}
        apu = buildAPDU(0x00, 0xA4, 0x04, 0x00, data, 0)
        rsp, err = card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initializing RP card: %w", err)
        }</span>

        <span class="cov0" title="0">if responseOK(rsp) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("initializing identity document card: unknown card type")</span>
}

func (card *Gemalto) ReadCard() error <span class="cov0" title="0">{
        var err error

        card.documentFile, err = card.ReadFile(ID_DOCUMENT_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading document file: %w", err)
        }</span>

        <span class="cov0" title="0">card.personalFile, err = card.ReadFile(ID_PERSONAL_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading personal file: %w", err)
        }</span>

        <span class="cov0" title="0">card.residenceFile, err = card.ReadFile(ID_RESIDENCE_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading residence file: %w", err)
        }</span>

        <span class="cov0" title="0">rsp, err := card.ReadFile(ID_PHOTO_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading photo file: %w", err)
        }</span>

        <span class="cov0" title="0">card.photoFile = trim4b(rsp)

        return nil</span>
}

func (card *Gemalto) GetDocument() (document.Document, error) <span class="cov0" title="0">{
        doc := document.IdDocument{}

        err := parseIdDocumentFile(card.documentFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing document file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseIdPersonalFile(card.personalFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing personal file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseIdResidenceFile(card.residenceFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing residence file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseAndAssignIdPhotoFile(card.photoFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing photo file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

func (card *Gemalto) Atr() Atr <span class="cov0" title="0">{
        return card.atr
}</span>

func (card *Gemalto) ReadFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        output := make([]byte, 0)

        _, err := card.selectFile(name, 0x08, 0x00, 4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := read(card.smartCard, 0, 4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading file header: %w", err)
        }</span>

        <span class="cov0" title="0">offset := uint(len(data))
        if offset &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file too short")
        }</span>
        <span class="cov0" title="0">length := uint(binary.LittleEndian.Uint16(data[2:]))

        for length &gt; 0 </span><span class="cov0" title="0">{
                data, err := read(card.smartCard, offset, length)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reading file: %w", err)
                }</span>

                <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">output = append(output, data...)

                offset += uint(len(data))
                length -= uint(len(data))</span>
        }

        <span class="cov0" title="0">return output, nil</span>
}

func (card *Gemalto) readCertificateFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        output := make([]byte, 0)

        _, err := card.selectFile(name, 0x00, 0x00, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := read(card.smartCard, 0, 2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading file header: %w", err)
        }</span>

        <span class="cov0" title="0">offset := uint(0)
        length := uint(binary.LittleEndian.Uint16(data)) + 2

        for length &gt; 0 </span><span class="cov0" title="0">{
                data, err := read(card.smartCard, offset, length)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reading file: %w", err)
                }</span>

                <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">output = append(output, data...)

                offset += uint(len(data))
                length -= uint(len(data))</span>
        }

        <span class="cov0" title="0">return output, nil</span>
}

func (card *Gemalto) selectFile(name []byte, selectionMethod, selectionOption byte, ne uint) ([]byte, error) <span class="cov0" title="0">{
        apu := buildAPDU(0x00, 0xA4, selectionMethod, selectionOption, name, ne)
        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: %w", err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: response %s", hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">return rsp, nil</span>
}

func (card *Gemalto) Test() bool <span class="cov0" title="0">{
        err := card.InitCard()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, err = card.ReadFile(ID_DOCUMENT_FILE_LOC)
        return err == nil</span>
}

// Initialize card's cryptography application
func (card *Gemalto) InitCrypto() error <span class="cov0" title="0">{
        aid := []byte{0xA0, 0x00, 0x00, 0x00, 0x63, 0x50, 0x4B, 0x43, 0x53, 0x2D, 0x31, 0x35}

        rsp, err := card.selectFile(aid, 0x04, 0x00, 0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initializing cryptography application %w", err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return fmt.Errorf("cryptography application not selected: response %s", hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Returns number of tries left, and occurred error.
// -1 signifies unknown number of tries left
func (card *Gemalto) ChangePin(newPin, oldPin string) (int, error) <span class="cov0" title="0">{
        err := card.smartCard.BeginTransaction()
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">err = card.InitCrypto()
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">oldPinValid := ValidatePin(oldPin)
        if !oldPinValid </span><span class="cov0" title="0">{
                return -1, errors.New("old pin not valid")
        }</span>

        <span class="cov0" title="0">newPinValid := ValidatePin(newPin)
        if !newPinValid </span><span class="cov0" title="0">{
                return -1, errors.New("new pin not valid")
        }</span>

        <span class="cov0" title="0">apu := buildAPDU(0x00, 0x20, 0x00, 0x80, PadPin(oldPin), 0)
        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("verifying old pin: %w", err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return PinTriesLeft(rsp), fmt.Errorf("verifying old pin: response %s", hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">data := make([]byte, 0, 8)
        data = append(data, PadPin(oldPin)...)
        data = append(data, PadPin(newPin)...)

        apu = buildAPDU(0x00, 0x24, 0x00, 0x80, data, 0)
        rsp, err = card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("changing pin: %w", err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return PinTriesLeft(rsp), fmt.Errorf("verifying old pin: response %s", hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">err = card.smartCard.EndTransaction(scard.LeaveCard)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">return -1, nil</span>
}

func (card *Gemalto) ReadSignatures() error <span class="cov0" title="0">{
        rsp, err := card.ReadFile([]byte{0x0F, 0x1C})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading signature 1: %w", err)
        }</span>
        <span class="cov0" title="0">card.signature[0] = trim4b(rsp)

        rsp, err = card.ReadFile([]byte{0x0F, 0x1D})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading signature 2: %w", err)
        }</span>
        <span class="cov0" title="0">card.signature[1] = trim4b(rsp)

        return nil</span>
}

func (card *Gemalto) LoadCertificates() error <span class="cov0" title="0">{
        if card.certificates != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err := card.InitCrypto()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">files := [][]byte{
                {0x71, 0x02},
                {0x71, 0x03},
        }

        var allErrors []error

        for _, file := range files </span><span class="cov0" title="0">{
                filename := hex.EncodeToString(file)

                rsp, err := card.readCertificateFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, fmt.Errorf("reading file %s: %w", filename, err))
                        continue</span>
                }

                <span class="cov0" title="0">if len(rsp) &lt; 8 </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, fmt.Errorf("file %s too short", filename))
                        continue</span>
                }

                <span class="cov0" title="0">byteReader := bytes.NewReader(rsp[6:])

                zlibReader, err := zlib.NewReader(byteReader)
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, fmt.Errorf("creating zlib reader for file %s: %w", filename, err))
                        continue</span>
                }

                <span class="cov0" title="0">defer zlibReader.Close()

                decompressed, err := io.ReadAll(zlibReader)
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, fmt.Errorf("decompressing certificate from file %s: %w", filename, err))
                        continue</span>
                }

                <span class="cov0" title="0">cert, err := x509.ParseCertificate(decompressed)
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, fmt.Errorf("parsing certificate from file %s: %w", filename, err))
                        continue</span>
                }

                <span class="cov0" title="0">card.certificates = append(card.certificates, cert)</span>
        }

        <span class="cov0" title="0">return errors.Join(allErrors...)</span>
}

func (card *Gemalto) GetCertificates() []x509.Certificate <span class="cov0" title="0">{
        certs := make([]x509.Certificate, 0, len(card.certificates))

        for _, c := range card.certificates </span><span class="cov0" title="0">{
                if c == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">newCert, err := x509.ParseCertificate(c.Raw)
                if err != nil || newCert == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">certs = append(certs, *newCert)</span>
        }

        <span class="cov0" title="0">return certs</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package card

import (
        "bytes"
        "fmt"
        "image"

        "github.com/ubavic/bas-celik/v2/card/tlv"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/localization"
)

// Location of the file with document data.
var ID_DOCUMENT_FILE_LOC = []byte{0x0F, 0x02}

// Location of the file with personal data.
var ID_PERSONAL_FILE_LOC = []byte{0x0F, 0x03}

// Location of the file with residence data.
var ID_RESIDENCE_FILE_LOC = []byte{0x0F, 0x04}

// Location of the the portrait. Portrait is encoded as JPEG.
var ID_PHOTO_FILE_LOC = []byte{0x0F, 0x06}

func parseIdDocumentFile(data []byte, doc *document.IdDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tlv.AssignField(fields, 1546, &amp;doc.DocRegNo)
        tlv.AssignField(fields, 1547, &amp;doc.DocumentType)
        tlv.AssignField(fields, 1548, &amp;doc.DocumentSerialNumber)
        tlv.AssignField(fields, 1549, &amp;doc.IssuingDate)
        tlv.AssignField(fields, 1550, &amp;doc.ExpiryDate)
        tlv.AssignField(fields, 1551, &amp;doc.IssuingAuthority)
        tlv.AssignField(fields, 1681, &amp;doc.ChipSerialNumber)
        tlv.AssignField(fields, 1682, &amp;doc.DocumentName)
        localization.FormatDate(&amp;doc.IssuingDate)
        localization.FormatDate(&amp;doc.ExpiryDate)

        return nil</span>
}

func parseIdPersonalFile(data []byte, doc *document.IdDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tlv.AssignField(fields, 1558, &amp;doc.PersonalNumber)
        tlv.AssignField(fields, 1559, &amp;doc.Surname)
        tlv.AssignField(fields, 1560, &amp;doc.GivenName)
        tlv.AssignField(fields, 1561, &amp;doc.ParentGivenName)
        tlv.AssignField(fields, 1562, &amp;doc.Sex)
        tlv.AssignField(fields, 1563, &amp;doc.PlaceOfBirth)
        tlv.AssignField(fields, 1564, &amp;doc.CommunityOfBirth)
        tlv.AssignField(fields, 1565, &amp;doc.StateOfBirth)
        tlv.AssignField(fields, 1566, &amp;doc.DateOfBirth)
        tlv.AssignField(fields, 1567, &amp;doc.StateOfBirthCode)
        tlv.AssignField(fields, 1583, &amp;doc.NationalityFull)
        tlv.AssignField(fields, 1683, &amp;doc.PurposeOfStay)
        tlv.AssignField(fields, 1684, &amp;doc.ENote)
        localization.FormatDate(&amp;doc.DateOfBirth)

        return nil</span>
}

func parseIdResidenceFile(data []byte, doc *document.IdDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tlv.AssignField(fields, 1568, &amp;doc.State)
        tlv.AssignField(fields, 1569, &amp;doc.Community)
        tlv.AssignField(fields, 1570, &amp;doc.Place)
        tlv.AssignField(fields, 1571, &amp;doc.Street)
        tlv.AssignField(fields, 1572, &amp;doc.HouseNumber)
        tlv.AssignField(fields, 1573, &amp;doc.HouseLetter)
        tlv.AssignField(fields, 1574, &amp;doc.Entrance)
        tlv.AssignField(fields, 1575, &amp;doc.Floor)
        tlv.AssignField(fields, 1578, &amp;doc.ApartmentNumber)
        tlv.AssignField(fields, 1580, &amp;doc.AddressDate)
        localization.FormatDate(&amp;doc.AddressDate)
        tlv.AssignField(fields, 1581, &amp;doc.AddressLabel)

        return nil</span>
}

func parseAndAssignIdPhotoFile(data []byte, doc *document.IdDocument) error <span class="cov0" title="0">{
        img, _, err := image.Decode(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("decoding photo file: %w", err)
        }</span>

        <span class="cov0" title="0">doc.Portrait = img

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package card

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "strings"

        "github.com/ubavic/bas-celik/v2/card/tlv"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/localization"
        "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/transform"
)

// Represents a smart card that holds a Serbian medical insurance document.
type MedicalCard struct {
        atr                  Atr
        smartCard            Card
        medicalDocumentFile  []byte
        fixedPersonalFile    []byte
        variablePersonalFile []byte
        variableAdminFile    []byte
}

// Possibly the first version of the medical card. Newer version has the GEMALTO_ATR_2 for the ATR.
var MEDICAL_ATR_1 = Atr([]byte{
        0x3B, 0xF4, 0x13, 0x00, 0x00, 0x81, 0x31, 0xFE,
        0x45, 0x52, 0x46, 0x5A, 0x4F, 0xED,
})

// Available since March 2023?
var MEDICAL_ATR_2 = Atr([]byte{
        0x3B, 0x9E, 0x97, 0x80, 0x31, 0xFE, 0x45, 0x53,
        0x43, 0x45, 0x20, 0x38, 0x2E, 0x30, 0x2D, 0x43,
        0x31, 0x56, 0x30, 0x0D, 0x0A, 0x6E,
})

// Location of the file with document data.
var MED_DOCUMENT_FILE_LOC = []byte{0x0D, 0x01}

// Location of the file with fixed personal data.
var MED_FIXED_PERSONAL_FILE_LOC = []byte{0x0D, 0x02}

// Location of the file with variable personal data.
var MED_VARIABLE_PERSONAL_FILE_LOC = []byte{0x0D, 0x03}

// Location of the file with variable administrative data.
var MED_VARIABLE_ADMIN_FILE_LOC = []byte{0x0D, 0x04}

func (card *MedicalCard) InitCard() error <span class="cov0" title="0">{
        s1 := []byte{0xF3, 0x81, 0x00, 0x00, 0x02, 0x53, 0x45, 0x52, 0x56, 0x53, 0x5A, 0x4B, 0x01}
        apu := buildAPDU(0x00, 0xA4, 0x04, 0x00, s1, 0)

        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return fmt.Errorf("initializing card: response %s", hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (card *MedicalCard) ReadCard() error <span class="cov0" title="0">{
        var err error

        card.medicalDocumentFile, err = card.ReadFile(MED_DOCUMENT_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading document file: %w", err)
        }</span>

        <span class="cov0" title="0">card.fixedPersonalFile, err = card.ReadFile(MED_FIXED_PERSONAL_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading fixed personal file: %w", err)
        }</span>

        <span class="cov0" title="0">card.variablePersonalFile, err = card.ReadFile(MED_VARIABLE_PERSONAL_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading variable personal file: %w", err)
        }</span>

        <span class="cov0" title="0">card.variableAdminFile, err = card.ReadFile(MED_VARIABLE_ADMIN_FILE_LOC)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading variable administrative file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (card *MedicalCard) GetDocument() (document.Document, error) <span class="cov0" title="0">{
        doc := document.MedicalDocument{}

        err := parseMedicalDocumentFile(card.medicalDocumentFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing document file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseMedicalFixedPersonalFile(card.fixedPersonalFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing fixed personal file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseMedicalVariablePersonalFile(card.variablePersonalFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing variable personal file: %w", err)
        }</span>

        <span class="cov0" title="0">err = parseMedicalVariableAdminFile(card.variableAdminFile, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing variable administrative file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

func (card *MedicalCard) Atr() Atr <span class="cov0" title="0">{
        return card.atr
}</span>

// Decodes UTF16 encoded data on medical cards.
func descramble(fields map[uint][]byte, tag uint) <span class="cov8" title="1">{
        bs, ok := fields[tag]
        if ok </span><span class="cov8" title="1">{
                utf8, _, err := transform.Bytes(unicode.UTF16(unicode.LittleEndian, unicode.UseBOM).NewDecoder(), bs)
                if err == nil </span><span class="cov8" title="1">{
                        fields[tag] = utf8
                        return
                }</span>
        }

        <span class="cov8" title="1">fields[tag] = []byte{}</span>
}

func (card *MedicalCard) ReadFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        output := make([]byte, 0)

        _, err := card.selectFile(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := read(card.smartCard, 0, 4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading file header: %w", err)
        }</span>

        <span class="cov0" title="0">offset := uint(len(data))
        if offset &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file too short")
        }</span>
        <span class="cov0" title="0">length := uint(binary.LittleEndian.Uint16(data[2:]))

        for length &gt; 0 </span><span class="cov0" title="0">{
                data, err := read(card.smartCard, offset, length)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reading file: %w", err)
                }</span>

                <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">output = append(output, data...)

                offset += uint(len(data))
                length -= uint(len(data))</span>
        }

        <span class="cov0" title="0">return output, nil</span>
}

func (card *MedicalCard) selectFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        apu := buildAPDU(0x00, 0xA4, 0x00, 0x00, name, 0)
        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file %s: %w", hex.EncodeToString(name), err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file %s: response %s", hex.EncodeToString(name), hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">return rsp, nil</span>
}

// Newer medical cards share ATR with the ID cards (GEMALTO_ATR_2)
func (card *MedicalCard) Test() bool <span class="cov0" title="0">{
        s1 := []byte{0xF3, 0x81, 0x00, 0x00, 0x02, 0x53, 0x45, 0x52, 0x56, 0x53, 0x5A, 0x4B, 0x01}
        apu := buildAPDU(0x00, 0xA4, 0x04, 0x00, s1, 0)
        _, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">rsp, err := card.ReadFile([]byte{0x0D, 0x01})
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">fields, err := tlv.ParseTLV(rsp)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">descramble(fields, 1553)

        return strings.Compare(string(fields[1553]), "    ") == 0</span>
}

func parseMedicalDocumentFile(data []byte, doc *document.MedicalDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">descramble(fields, 1553)
        tlv.AssignField(fields, 1553, &amp;doc.InsurerName)
        tlv.AssignField(fields, 1554, &amp;doc.InsurerID)
        tlv.AssignField(fields, 1555, &amp;doc.CardId)
        tlv.AssignField(fields, 1557, &amp;doc.DateOfIssue)
        localization.FormatDate(&amp;doc.DateOfIssue)
        tlv.AssignField(fields, 1558, &amp;doc.DateOfExpiry)
        localization.FormatDate(&amp;doc.DateOfExpiry)
        tlv.AssignField(fields, 1560, &amp;doc.PrintLanguage)

        return nil</span>
}

func parseMedicalFixedPersonalFile(data []byte, doc *document.MedicalDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">descramble(fields, 1570)
        tlv.AssignField(fields, 1570, &amp;doc.FamilyName)
        descramble(fields, 1571)
        tlv.AssignField(fields, 1571, &amp;doc.FamilyNameLatin)
        descramble(fields, 1572)
        tlv.AssignField(fields, 1572, &amp;doc.GivenName)
        descramble(fields, 1573)
        tlv.AssignField(fields, 1573, &amp;doc.GivenNameLatin)
        tlv.AssignField(fields, 1574, &amp;doc.DateOfBirth)
        localization.FormatDate(&amp;doc.DateOfBirth)
        tlv.AssignField(fields, 1569, &amp;doc.InsurantNumber)

        return nil</span>
}

func parseMedicalVariablePersonalFile(data []byte, doc *document.MedicalDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tlv.AssignField(fields, 1586, &amp;doc.ValidUntil)
        localization.FormatDate(&amp;doc.ValidUntil)
        tlv.AssignBoolField(fields, 1587, &amp;doc.PermanentlyValid)

        return nil</span>
}

func parseMedicalVariableAdminFile(data []byte, doc *document.MedicalDocument) error <span class="cov0" title="0">{
        fields, err := tlv.ParseTLV(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">descramble(fields, 1601)
        tlv.AssignField(fields, 1601, &amp;doc.ParentName)
        descramble(fields, 1602)
        tlv.AssignField(fields, 1602, &amp;doc.ParentNameLatin)
        if string(fields[1603]) == "01" </span><span class="cov0" title="0">{
                doc.Gender = "M"
        }</span> else<span class="cov0" title="0"> {
                doc.Gender = ""
        }</span>
        <span class="cov0" title="0">tlv.AssignField(fields, 1604, &amp;doc.PersonalNumber)
        descramble(fields, 1605)
        tlv.AssignField(fields, 1605, &amp;doc.Street)
        descramble(fields, 1607)
        tlv.AssignField(fields, 1607, &amp;doc.Municipality)
        descramble(fields, 1608)
        tlv.AssignField(fields, 1608, &amp;doc.Place)
        descramble(fields, 1610)
        tlv.AssignField(fields, 1610, &amp;doc.Number)
        descramble(fields, 1612)
        tlv.AssignField(fields, 1612, &amp;doc.Apartment)
        tlv.AssignField(fields, 1614, &amp;doc.InsuranceBasisRZZO)
        descramble(fields, 1615)
        tlv.AssignField(fields, 1615, &amp;doc.InsuranceDescription)
        descramble(fields, 1616)
        tlv.AssignField(fields, 1616, &amp;doc.CarrierRelationship)
        tlv.AssignBoolField(fields, 1617, &amp;doc.CarrierFamilyMember)
        tlv.AssignField(fields, 1618, &amp;doc.CarrierIdNumber)
        tlv.AssignField(fields, 1619, &amp;doc.CarrierInsurantNumber)
        descramble(fields, 1620)
        tlv.AssignField(fields, 1620, &amp;doc.CarrierFamilyName)
        descramble(fields, 1621)
        tlv.AssignField(fields, 1621, &amp;doc.CarrierFamilyNameLatin)
        descramble(fields, 1622)
        tlv.AssignField(fields, 1622, &amp;doc.CarrierGivenName)
        descramble(fields, 1623)
        tlv.AssignField(fields, 1623, &amp;doc.CarrierGivenNameLatin)
        tlv.AssignField(fields, 1624, &amp;doc.InsuranceStartDate)
        localization.FormatDate(&amp;doc.InsuranceStartDate)
        descramble(fields, 1626)
        tlv.AssignField(fields, 1626, &amp;doc.Country)
        descramble(fields, 1630)
        tlv.AssignField(fields, 1630, &amp;doc.TaxpayerName)
        descramble(fields, 1631)
        tlv.AssignField(fields, 1631, &amp;doc.TaxpayerResidence)
        tlv.AssignField(fields, 1632, &amp;doc.TaxpayerIdNumber)
        if len(doc.TaxpayerIdNumber) == 0 </span><span class="cov0" title="0">{
                tlv.AssignField(fields, 1633, &amp;doc.TaxpayerIdNumber)
        }</span>
        <span class="cov0" title="0">tlv.AssignField(fields, 1634, &amp;doc.TaxpayerActivityCode)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package card

import (
        "slices"
        "unicode"
)

// Checks if the PIN consists only of digits,
// and it's length is between 4 and 8.
func ValidatePin(pin string) bool <span class="cov8" title="1">{
        pinLength := len(pin)
        if pinLength &lt; 4 || pinLength &gt; 8 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range pin </span><span class="cov8" title="1">{
                if !unicode.IsDigit(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// Creates a 8 byte slice containing the PIN at the beginning.
func PadPin(pin string) []byte <span class="cov8" title="1">{
        data := make([]byte, 8)

        for i, r := range pin </span><span class="cov8" title="1">{
                if i &lt; 8 </span><span class="cov8" title="1">{
                        data[i] = byte(r)
                }</span>
        }

        <span class="cov8" title="1">return data</span>
}

func PinTriesLeft(rsp []byte) int <span class="cov8" title="1">{
        if slices.Equal(rsp, []byte{0x63, 0xC0}) || slices.Equal(rsp, []byte{0x69, 0x83}) </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">if slices.Equal(rsp, []byte{0x63, 0xC1}) </span><span class="cov8" title="1">{
                return 1
        }</span>

        <span class="cov8" title="1">if slices.Equal(rsp, []byte{0x63, 0xC2}) </span><span class="cov8" title="1">{
                return 2
        }</span>

        <span class="cov8" title="1">if slices.Equal(rsp, []byte{0x63, 0xC3}) </span><span class="cov8" title="1">{
                return 3
        }</span>

        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package card

import "github.com/ebfe/scard"

type VirtualCard struct {
        atr   []byte
        files map[uint32][]byte
}

func MakeVirtualCard(atr []byte, fs map[uint32][]byte) *VirtualCard <span class="cov0" title="0">{
        vc := VirtualCard{
                atr:   atr,
                files: fs,
        }

        return &amp;vc
}</span>

func (card *VirtualCard) Status() (*scard.CardStatus, error) <span class="cov0" title="0">{
        status := scard.CardStatus{Atr: card.atr, Reader: "Virtual", State: scard.Powered}
        return &amp;status, nil
}</span>

func Transmit(cmd []byte) ([]byte, error) <span class="cov0" title="0">{
        return []byte{0x90, 0x00}, nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package card

import (
        "strings"

        "github.com/ebfe/scard"
)

func FormatState(state scard.StateFlag) string <span class="cov0" title="0">{
        states := []string{}

        if state&amp;scard.StateUnaware != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateUnaware")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateIgnore != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateIgnore")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateChanged != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateChanged")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateUnknown != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateUnknown")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StatePresent != 0 </span><span class="cov0" title="0">{
                states = append(states, "StatePresent")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateAtrmatch != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateAtrmatch")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateExclusive != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateExclusive")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateMute != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateMute")
        }</span>
        <span class="cov0" title="0">if state&amp;scard.StateUnpowered != 0 </span><span class="cov0" title="0">{
                states = append(states, "StateUnpowered")
        }</span>

        <span class="cov0" title="0">return strings.Join(states, " ")</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tlv

import (
        "encoding/binary"
        "fmt"

        "github.com/ubavic/bas-celik/v2/card/cardErrors"
)

// Parses simple TLV-encoded data and returns a map of tags to values.
// It assumes that tag and length are encoded with two bytes each.
func ParseTLV(data []byte) (map[uint][]byte, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return nil, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">m := make(map[uint][]byte)
        offset := uint(0)

        for </span><span class="cov8" title="1">{
                if uint(len(data)) &lt;= offset+4 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("parsing TLV record tag and length: %w", cardErrors.ErrInvalidLength)
                }</span>

                <span class="cov8" title="1">tag := uint(binary.LittleEndian.Uint16(data[offset:]))
                length := uint(binary.LittleEndian.Uint16(data[offset+2:]))

                offset += 4

                if offset+length &gt; uint(len(data)) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("parsing TLV record data: %w", cardErrors.ErrInvalidLength)
                }</span>

                <span class="cov8" title="1">value := data[offset : offset+length]
                m[tag] = value
                offset += length

                if offset &gt;= uint(len(data)) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return m, nil</span>
}

// Assigns the value from the provided fields map to the target string, based on the specified tag.
// If the tag is not present in the map, the target is set to an empty string.
func AssignField[T comparable](fields map[T][]byte, tag T, target *string) <span class="cov8" title="1">{
        val, ok := fields[tag]
        if ok </span><span class="cov8" title="1">{
                *target = string(val)
        }</span> else<span class="cov8" title="1"> {
                *target = ""
        }</span>
}

// Assigns a boolean value from the provided fields map to the target, based on the specified tag.
// If the tag is not present in the map or the value is not 0x31, the target is set to false.
func AssignBoolField(fields map[uint][]byte, tag uint, target *bool) <span class="cov8" title="1">{
        val, ok := fields[tag]
        if ok &amp;&amp; len(val) == 1 &amp;&amp; val[0] == 0x31 </span><span class="cov8" title="1">{
                *target = true
        }</span> else<span class="cov8" title="1"> {
                *target = false
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package card

import (
        "errors"

        "github.com/ubavic/bas-celik/v2/document"
)

type UnknownDocumentCard struct {
        atr       Atr
        smartCard Card
}

func (card *UnknownDocumentCard) Atr() Atr <span class="cov0" title="0">{
        return card.atr
}</span>

func (card *UnknownDocumentCard) ReadFile(_ []byte) ([]byte, error) <span class="cov0" title="0">{
        return nil, errors.New("not implemented")
}</span>

func (card *UnknownDocumentCard) InitCard() error <span class="cov0" title="0">{
        return nil
}</span>

func (card *UnknownDocumentCard) ReadCard() error <span class="cov0" title="0">{
        return nil
}</span>

func (card *UnknownDocumentCard) GetDocument() (document.Document, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (card *UnknownDocumentCard) Test() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package card

import (
        "encoding/hex"
        "fmt"

        "github.com/ubavic/bas-celik/v2/card/ber"
        "github.com/ubavic/bas-celik/v2/card/cardErrors"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/localization"
)

// Represents a smart card that contains a Serbian vehicle document.
type VehicleCard struct {
        atr       Atr
        smartCard Card
        files     [4][]byte
}

// Possibly deprecated.
var VEHICLE_ATR_0 = Atr([]byte{
        0x3B, 0xDB, 0x96, 0x00, 0x80, 0xB1, 0xFE, 0x45,
        0x1F, 0x83, 0x00, 0x31, 0xC0, 0x64, 0x1A, 0x18,
        0x01, 0x00, 0x0F, 0x90, 0x00, 0x52,
})

// Same as GEMALTO_ATR_1
var VEHICLE_ATR_1 = Atr([]byte{
        0x3B, 0xFF, 0x94, 0x00, 0x00, 0x81, 0x31, 0x80,
        0x43, 0x80, 0x31, 0x80, 0x65, 0xB0, 0x85, 0x02,
        0x01, 0xF3, 0x12, 0x0F, 0xFF, 0x82, 0x90, 0x00,
        0x79,
})

var VEHICLE_ATR_2 = Atr([]byte{
        0x3B, 0x9D, 0x13, 0x81, 0x31, 0x60, 0x37, 0x80,
        0x31, 0xC0, 0x69, 0x4D, 0x54, 0x43, 0x4F, 0x53,
        0x73, 0x02, 0x02, 0x04, 0x40,
})

var VEHICLE_ATR_3 = Atr([]byte{
        0x3B, 0x9D, 0x13, 0x81, 0x31, 0x60, 0x37, 0x80,
        0x31, 0xC0, 0x69, 0x4D, 0x54, 0x43, 0x4F, 0x53,
        0x73, 0x02, 0x05, 0x04, 0x47,
})

var VEHICLE_ATR_4 = Atr([]byte{
        0x3B, 0x9D, 0x18, 0x81, 0x31, 0xFC, 0x35, 0x80,
        0x31, 0xC0, 0x69, 0x4D, 0x54, 0x43, 0x4F, 0x53,
        0x73, 0x02, 0x05, 0x02, 0xD4,
})

// Initializes vehicle card by trying three different sets of commands.
// The procedure is reverse-engineered from the official binary.
func (card VehicleCard) InitCard() error <span class="cov0" title="0">{
        tryToSelect := func(cmd1, cmd2, cmd3 []byte) error </span><span class="cov0" title="0">{
                apu := buildAPDU(0x00, 0xA4, 0x04, 0x00, cmd1, 0)
                rsp, err := card.smartCard.Transmit(apu)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("selecting file: %w", err)
                }</span>

                <span class="cov0" title="0">if responseOK(rsp) </span><span class="cov0" title="0">{
                        apu = buildAPDU(0x00, 0xA4, 0x04, 0x00, cmd2, 0)
                        _, err = card.smartCard.Transmit(apu)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("selecting file: %w", err)
                        }</span>

                        <span class="cov0" title="0">apu = buildAPDU(0x00, 0xA4, 0x04, 0x0C, cmd3, 0)
                        _, err = card.smartCard.Transmit(apu)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("selecting file: %w", err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("selecting file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">err := tryToSelect(
                []byte{0xA0, 0x00, 0x00, 0x01, 0x51, 0x00, 0x00},
                []byte{0xA0, 0x00, 0x00, 0x00, 0x77, 0x01, 0x08, 0x00, 0x07, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x01, 0x00},
                []byte{0xA0, 0x00, 0x00, 0x00, 0x77, 0x01, 0x08, 0x00, 0x07, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xAD, 0xF2})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err = tryToSelect(
                []byte{0xA0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00},
                []byte{0xF3, 0x81, 0x00, 0x00, 0x02, 0x53, 0x45, 0x52, 0x56, 0x4C, 0x04, 0x02, 0x01},
                []byte{0xA0, 0x00, 0x00, 0x00, 0x77, 0x01, 0x08, 0x00, 0x07, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xAD, 0xF2})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err = tryToSelect(
                []byte{0xA0, 0x00, 0x00, 0x00, 0x18, 0x43, 0x4D, 0x00},
                []byte{0xA0, 0x00, 0x00, 0x00, 0x18, 0x34, 0x14, 0x01, 0x00, 0x65, 0x56, 0x4C, 0x2D, 0x30, 0x30, 0x31},
                []byte{0xA0, 0x00, 0x00, 0x00, 0x18, 0x65, 0x56, 0x4C, 0x2D, 0x30, 0x30, 0x31})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("card not responsive: %w", err)</span>
}

func (card *VehicleCard) ReadCard() error <span class="cov0" title="0">{
        var err error

        for i := byte(0); i &lt;= 3; i++ </span><span class="cov0" title="0">{
                card.files[int(i)], err = card.ReadFile([]byte{0xD0, i*0x10 + 0x01})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("reading document %d file: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (card *VehicleCard) GetDocument() (document.Document, error) <span class="cov0" title="0">{
        doc := document.VehicleDocument{}
        data := ber.BER{}

        for i := byte(0); i &lt;= 3; i++ </span><span class="cov0" title="0">{
                parsed, err := ber.ParseBER(card.files[int(i)])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parsing %d file: %w", i, err)
                }</span>

                <span class="cov0" title="0">err = data.Merge(*parsed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("merging %d data: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">data.AssignFrom(&amp;doc.RegistrationNumberOfVehicle, 0x71, 0x81)
        data.AssignFrom(&amp;doc.DateOfFirstRegistration, 0x71, 0x82)
        localization.FormatDateYMD(&amp;doc.DateOfFirstRegistration)
        data.AssignFrom(&amp;doc.VehicleIdNumber, 0x71, 0x8A)
        data.AssignFrom(&amp;doc.VehicleMass, 0x71, 0x8C)
        data.AssignFrom(&amp;doc.ExpiryDate, 0x71, 0x8D)
        localization.FormatDateYMD(&amp;doc.ExpiryDate)
        data.AssignFrom(&amp;doc.IssuingDate, 0x71, 0x8E)
        localization.FormatDateYMD(&amp;doc.IssuingDate)
        data.AssignFrom(&amp;doc.TypeApprovalNumber, 0x71, 0x8F)
        data.AssignFrom(&amp;doc.PowerWeightRatio, 0x71, 0x93)
        data.AssignFrom(&amp;doc.VehicleMake, 0x71, 0xA3, 0x87)
        data.AssignFrom(&amp;doc.VehicleType, 0x71, 0xA3, 0x88)
        data.AssignFrom(&amp;doc.CommercialDescription, 0x71, 0xA3, 0x89)
        data.AssignFrom(&amp;doc.MaximumPermissibleLadenMass, 0x71, 0xA4, 0x8B)
        data.AssignFrom(&amp;doc.EngineCapacity, 0x71, 0xA5, 0x90)
        data.AssignFrom(&amp;doc.MaximumNetPower, 0x71, 0xA5, 0x91)
        data.AssignFrom(&amp;doc.TypeOfFuel, 0x71, 0xA5, 0x92)
        data.AssignFrom(&amp;doc.NumberOfSeats, 0x71, 0xA6, 0x94)
        data.AssignFrom(&amp;doc.NumberOfStandingPlaces, 0x71, 0xA6, 0x95)
        data.AssignFrom(&amp;doc.StateIssuing, 0x71, 0x9F33)
        data.AssignFrom(&amp;doc.CompetentAuthority, 0x71, 0x9F35)
        data.AssignFrom(&amp;doc.AuthorityIssuing, 0x71, 0x9F36)
        data.AssignFrom(&amp;doc.UnambiguousNumber, 0x71, 0x9F38)
        data.AssignFrom(&amp;doc.VehicleCategory, 0x72, 0x98)
        data.AssignFrom(&amp;doc.NumberOfAxles, 0x72, 0x99)
        data.AssignFrom(&amp;doc.VehicleLoad, 0x72, 0xC4)
        data.AssignFrom(&amp;doc.YearOfProduction, 0x72, 0xC5)
        data.AssignFrom(&amp;doc.EngineIdNumber, 0x72, 0xA5, 0x9E)
        data.AssignFrom(&amp;doc.SerialNumber, 0x72, 0xC9)
        data.AssignFrom(&amp;doc.ColourOfVehicle, 0x72, 0x9F24)
        data.AssignFrom(&amp;doc.UsersPersonalNo, 0x72, 0xC3)
        data.AssignFrom(&amp;doc.OwnersPersonalNo, 0x72, 0xC2)

        data.AssignFrom(&amp;doc.OwnersSurnameOrBusinessName, 0x71, 0xA1, 0xA2, 0x83)
        data.AssignFrom(&amp;doc.OwnerName, 0x71, 0xA1, 0xA2, 0x84)
        data.AssignFrom(&amp;doc.OwnerAddress, 0x71, 0xA1, 0xA2, 0x85)

        data.AssignFrom(&amp;doc.UsersSurnameOrBusinessName, 0x71, 0xA1, 0xA9, 0x83)
        data.AssignFrom(&amp;doc.UsersName, 0x71, 0xA1, 0xA9, 0x84)
        data.AssignFrom(&amp;doc.UsersAddress, 0x71, 0xA1, 0xA9, 0x85)
        if doc.UsersName == "" &amp;&amp; doc.UsersSurnameOrBusinessName == "" &amp;&amp; doc.UsersAddress == "" </span><span class="cov0" title="0">{
                data.AssignFrom(&amp;doc.UsersSurnameOrBusinessName, 0x72, 0xA1, 0xA9, 0x83)
                data.AssignFrom(&amp;doc.UsersName, 0x72, 0xA1, 0xA9, 0x84)
                data.AssignFrom(&amp;doc.UsersAddress, 0x72, 0xA1, 0xA9, 0x85)
        }</span>

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

func (card *VehicleCard) Atr() Atr <span class="cov0" title="0">{
        return card.atr
}</span>

func (card *VehicleCard) ReadFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        output := make([]byte, 0)

        _, err := card.selectFile(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file: %w", err)
        }</span>

        <span class="cov0" title="0">const headerSize = uint(0x20)

        header, err := read(card.smartCard, 0, headerSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading file header: %w", err)
        }</span>

        <span class="cov0" title="0">length, offset, err := parseVehicleCardFileSize(header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing file header: %w", err)
        }</span>

        <span class="cov0" title="0">for length &gt; 0 </span><span class="cov0" title="0">{
                toRead := min(length, 0x64)
                data, err := read(card.smartCard, offset, toRead)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("reading file: %w", err)
                }</span>

                <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">output = append(output, data...)

                offset += uint(len(data))
                length -= uint(len(data))</span>
        }

        <span class="cov0" title="0">return output, nil</span>
}

func (card VehicleCard) Test() bool <span class="cov0" title="0">{
        err := card.InitCard()
        return err == nil
}</span>

func parseVehicleCardFileSize(data []byte) (uint, uint, error) <span class="cov8" title="1">{
        if len(data) &lt; 1 </span><span class="cov8" title="1">{
                return 0, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">offset := uint(data[1]) + 2

        if offset &gt;= uint(len(data)) </span><span class="cov8" title="1">{
                return 0, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">_, _, offsetDelta1, err := ber.ParseTag(data[offset:])
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("parsing tag: %w", err)
        }</span>

        <span class="cov8" title="1">if offset+uint(offsetDelta1) &gt;= uint(len(data)) </span><span class="cov8" title="1">{
                return 0, 0, cardErrors.ErrInvalidLength
        }</span>

        <span class="cov8" title="1">dataLength, offsetDelta2, err := ber.ParseLength(data[offset+uint(offsetDelta1):])
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("parsing size: %w", err)
        }</span>

        <span class="cov8" title="1">length := uint(dataLength + offsetDelta1 + offsetDelta2)

        return length, offset, nil</span>
}

func (card *VehicleCard) selectFile(name []byte) ([]byte, error) <span class="cov0" title="0">{
        apu := buildAPDU(0x00, 0xA4, 0x02, 0x04, name, 0)

        rsp, err := card.smartCard.Transmit(apu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file %s: %w", hex.EncodeToString(name), err)
        }</span>

        <span class="cov0" title="0">if !responseOK(rsp) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("selecting file %s: response %s", hex.EncodeToString(name), hex.EncodeToString(rsp))
        }</span>

        <span class="cov0" title="0">return rsp, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package provides type definitions fot different types of documents
// present on smart cards, as well methods for exporting those documents to different file formats.
// In order for `BuildPDF` methods to work properly,
// this package must be (pre)configured with `Configure` function.
package document

// Represents any document handled by Bas Celik
type Document interface {
        BuildPdf() ([]byte, string, error)   // Renders document to pdf
        BuildJson() ([]byte, error)          // Renders document to json
        BuildExcel() ([]byte, string, error) // Renders document to xlsx
}

var (
        fontRegular []byte
        fontBold    []byte
        rfzoLogo    []byte
)

type DocumentConfig struct {
        FontRegular []byte // regular font used for PDF render
        FontBold    []byte // bold font used for PDF render
        RfzoLogo    []byte // logo used in PDF render of medical cards
}

// Sets fonts and graphics used for rendering PDF
func Configure(config DocumentConfig) error <span class="cov8" title="1">{
        fontRegular = config.FontRegular
        fontBold = config.FontBold
        rfzoLogo = config.RfzoLogo

        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package document

import (
        "bytes"
        "errors"
        "fmt"
        "reflect"

        "github.com/ubavic/bas-celik/v2/localization"
        "github.com/xuri/excelize/v2"
)

func CreateExcel(document any) ([]byte, error) <span class="cov0" title="0">{
        structType := reflect.TypeOf(document)
        structVal := reflect.ValueOf(document)

        if structType.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, errors.New("not a struct")
        }</span>

        <span class="cov0" title="0">f := excelize.NewFile()

        err := f.SetColWidth("Sheet1", "A", "A", 30)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = f.SetColWidth("Sheet1", "B", "B", 60)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">currentRow := 1
        putData := func(label, value string) </span><span class="cov0" title="0">{
                f.SetCellValue("Sheet1", fmt.Sprintf("A%d", currentRow), label)
                f.SetCellValue("Sheet1", fmt.Sprintf("B%d", currentRow), value)
                currentRow += 1
        }</span>

        <span class="cov0" title="0">fields := reflect.VisibleFields(structType)

        for _, field := range fields </span><span class="cov0" title="0">{
                switch field.Type.Kind() </span>{
                case reflect.String:<span class="cov0" title="0">
                        putData(field.Name, structVal.FieldByName(field.Name).String())</span>
                case reflect.Bool:<span class="cov0" title="0">
                        str := localization.FormatYesNo(structVal.FieldByName(field.Name).Bool(), localization.En)
                        putData(field.Name, str)</span>
                }
        }

        <span class="cov0" title="0">buffer := bytes.Buffer{}

        err = f.Write(&amp;buffer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package document

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "image"
        "image/jpeg"
        "strings"
        "time"

        "github.com/signintech/gopdf"
        "github.com/ubavic/bas-celik/v2/localization"
)

const ID_TYPE_APOLLO = ""
const ID_TYPE_ID = "ID"
const ID_TYPE_IDENTITY_FOREIGNER = "IF"
const ID_TYPE_RESIDENCE_PERMIT = "RP"

// Represents a document stored on a Serbian ID card.
type IdDocument struct {
        Portrait             image.Image
        DocRegNo             string
        DocumentType         string
        IssuingDate          string
        ExpiryDate           string
        IssuingAuthority     string
        DocumentSerialNumber string
        ChipSerialNumber     string
        DocumentName         string
        PersonalNumber       string
        Surname              string
        GivenName            string
        ParentGivenName      string
        Sex                  string
        PlaceOfBirth         string
        CommunityOfBirth     string
        StateOfBirth         string
        StateOfBirthCode     string
        DateOfBirth          string
        StatusOfForeigner    string
        NationalityFull      string
        PurposeOfStay        string
        ENote                string
        State                string
        Community            string
        Place                string
        Street               string
        HouseNumber          string
        HouseLetter          string
        Entrance             string
        Floor                string
        ApartmentNumber      string
        AddressDate          string
        AddressLabel         string
}

func (doc *IdDocument) GetFullName() string <span class="cov8" title="1">{
        return localization.JoinWithComma(doc.GivenName, doc.ParentGivenName, doc.Surname)
}</span>

func (doc *IdDocument) GetFullAddress(reverse bool) string <span class="cov8" title="1">{
        var streetAndNumber = doc.Street

        if doc.HouseNumber != "" || doc.HouseLetter != "" || doc.Entrance != "" </span><span class="cov8" title="1">{
                streetAndNumber += " " + doc.HouseNumber + doc.HouseLetter

                if doc.Floor != "" </span><span class="cov8" title="1">{
                        streetAndNumber += "/" + doc.Floor
                }</span>

                <span class="cov8" title="1">if doc.ApartmentNumber != "" </span><span class="cov8" title="1">{
                        streetAndNumber += "/" + doc.ApartmentNumber
                }</span>
        }

        <span class="cov8" title="1">if reverse </span><span class="cov8" title="1">{
                return localization.JoinWithComma(doc.Place, doc.Community, streetAndNumber)
        }</span> else<span class="cov8" title="1"> {
                return localization.JoinWithComma(streetAndNumber, doc.Community, doc.Place)
        }</span>
}

func (doc *IdDocument) GetFullPlaceOfBirth() string <span class="cov8" title="1">{
        return localization.JoinWithComma(doc.PlaceOfBirth, doc.CommunityOfBirth, doc.StateOfBirth)
}</span>

func (doc *IdDocument) BuildPdf() (data []byte, fileName string, retErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        switch x := r.(type) </span>{
                        case error:<span class="cov8" title="1">
                                retErr = x</span>
                        default:<span class="cov0" title="0">
                                retErr = errors.New("unknown panic")</span>
                        }
                }
        }()

        <span class="cov8" title="1">pdf := gopdf.GoPdf{}
        pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4})

        pdf.AddPage()

        err := pdf.AddTTFFontData("liberationsans", fontRegular)
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Errorf("loading font: %w", err))</span>
        }

        <span class="cov8" title="1">err = pdf.SetFont("liberationsans", "", 13.5)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("setting font: %w", err))</span>
        }

        <span class="cov8" title="1">ipw := IdPdfWriter{
                pdf:            &amp;pdf,
                leftMargin:     58.8,
                rightMargin:    535,
                textLeftMargin: 67.3,
                doc:            doc,
        }

        if doc.DocumentType == ID_TYPE_APOLLO || doc.DocumentType == ID_TYPE_ID </span><span class="cov8" title="1">{
                ipw.printRegularId()
        }</span> else<span class="cov0" title="0"> if doc.DocumentType == ID_TYPE_IDENTITY_FOREIGNER </span><span class="cov0" title="0">{
                ipw.printForeignerId()
        }</span> else<span class="cov0" title="0"> if doc.DocumentType == ID_TYPE_RESIDENCE_PERMIT </span><span class="cov0" title="0">{
                ipw.printResidencePermit()
        }</span>

        <span class="cov8" title="1">fileName = doc.formatFilename() + ".pdf"

        pdf.SetInfo(gopdf.PdfInfo{
                Title:        doc.GivenName + " " + doc.Surname,
                Author:       "Ba elik",
                Subject:      "Lina karta",
                CreationDate: time.Now(),
        })

        return pdf.GetBytesPdf(), fileName, nil</span>
}

func (doc *IdDocument) BuildJson() ([]byte, error) <span class="cov0" title="0">{
        var bs bytes.Buffer
        err := jpeg.Encode(&amp;bs, doc.Portrait, &amp;jpeg.Options{Quality: 100})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating json: %w", err)
        }</span>

        <span class="cov0" title="0">type Alias IdDocument
        return json.Marshal(&amp;struct {
                Portrait string
                *Alias
        }{
                Portrait: base64.StdEncoding.EncodeToString(bs.Bytes()),
                Alias:    (*Alias)(doc),
        })</span>
}

func (doc *IdDocument) BuildExcel() ([]byte, string, error) <span class="cov0" title="0">{
        xlsx, err := CreateExcel(*doc)
        filename := doc.formatFilename() + ".xlsx"
        return xlsx, filename, err
}</span>

func (doc *IdDocument) formatFilename() string <span class="cov8" title="1">{
        return strings.ToLower(doc.GivenName + "_" + doc.Surname)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package document

import (
        "fmt"
        "math"
        "time"

        "github.com/signintech/gopdf"
        "github.com/ubavic/bas-celik/v2/localization"
)

type IdPdfWriter struct {
        pdf            *gopdf.GoPdf
        leftMargin     float64
        rightMargin    float64
        textLeftMargin float64
        doc            *IdDocument
}

func (idw *IdPdfWriter) line(width float64) <span class="cov8" title="1">{
        if width &gt; 0 </span><span class="cov8" title="1">{
                idw.pdf.SetLineWidth(width)
        }</span>

        <span class="cov8" title="1">y := idw.pdf.GetY()
        idw.pdf.Line(idw.leftMargin, y, idw.rightMargin, y)</span>
}

func (idw *IdPdfWriter) moveY(y float64) <span class="cov8" title="1">{
        idw.pdf.SetXY(idw.pdf.GetX(), idw.pdf.GetY()+y)
}</span>

func (idw *IdPdfWriter) cell(s string) <span class="cov8" title="1">{
        err := idw.pdf.Cell(nil, s)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("putting text: %w", err))</span>
        }
}

func (idw *IdPdfWriter) putData(label, data string) <span class="cov8" title="1">{
        y := idw.pdf.GetY()

        idw.pdf.SetX(idw.textLeftMargin)
        texts, err := idw.pdf.SplitTextWithWordWrap(label, 120)
        if err != nil &amp;&amp; err != gopdf.ErrEmptyString </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">for i, text := range texts </span><span class="cov8" title="1">{
                idw.cell(text)
                if i &lt; len(texts)-1 </span><span class="cov8" title="1">{
                        idw.pdf.SetXY(idw.textLeftMargin, idw.pdf.GetY()+12)
                }</span>
        }

        <span class="cov8" title="1">y1 := idw.pdf.GetY()

        idw.pdf.SetXY(idw.textLeftMargin+128, y)
        texts, err = idw.pdf.SplitTextWithWordWrap(data, 350)
        if err != nil &amp;&amp; err != gopdf.ErrEmptyString </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">for i, text := range texts </span><span class="cov8" title="1">{
                idw.cell(text)
                if i &lt; len(texts)-1 </span><span class="cov0" title="0">{
                        idw.pdf.SetXY(idw.textLeftMargin+128, idw.pdf.GetY()+12)
                }</span>
        }

        <span class="cov8" title="1">y2 := idw.pdf.GetY()

        idw.pdf.SetXY(idw.textLeftMargin, math.Max(y1, y2)+24.67)</span>
}

func (ipw *IdPdfWriter) printRegularId() <span class="cov8" title="1">{
        ipw.pdf.SetLineType("solid")
        ipw.pdf.SetY(59.041)
        ipw.line(0.83)

        ipw.pdf.SetXY(ipw.textLeftMargin+1.0, 68.5)

        err := ipw.pdf.SetCharSpacing(-0.2)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">ipw.cell("ITA ELEKTRONSKE LINE KARTE: TAMPA PODATAKA")

        err = ipw.pdf.SetCharSpacing(-0.1)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ipw.pdf.SetY(88)

        ipw.line(0)

        imageY := 102.8
        imageHeight := 159.0

        err = ipw.pdf.ImageFrom(ipw.doc.Portrait, ipw.leftMargin, imageY, &amp;gopdf.Rect{W: 119.9, H: imageHeight})
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ipw.pdf.SetLineWidth(0.48)
        ipw.pdf.SetFillColor(255, 255, 255)
        err = ipw.pdf.Rectangle(ipw.leftMargin, imageY, 179, imageY+imageHeight, "D", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ipw.pdf.SetFillColor(0, 0, 0)

        ipw.pdf.SetY(276)

        ipw.line(1.08)
        ipw.moveY(8)
        ipw.pdf.SetX(ipw.textLeftMargin)
        err = ipw.pdf.SetFontSize(11.1)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ipw.cell("Podaci o graaninu")

        ipw.moveY(16)
        ipw.line(0)
        ipw.moveY(9)

        ipw.putData("Prezime:", ipw.doc.Surname)
        ipw.putData("Ime:", ipw.doc.GivenName)
        ipw.putData("Ime jednog roditelja:", ipw.doc.ParentGivenName)
        ipw.putData("Datum roenja:", ipw.doc.DateOfBirth)
        ipw.putData("Mesto roenja,\noptina i drava:", ipw.doc.GetFullPlaceOfBirth())
        addressLabel := "Prebivalite\ni adresa stana:"
        if ipw.doc.AddressLabel == "prebivalite" </span><span class="cov0" title="0">{
                addressLabel = "Prebivalite:"
        }</span>
        <span class="cov8" title="1">ipw.putData(addressLabel, ipw.doc.GetFullAddress(true))
        ipw.putData("Datum promene adrese:", ipw.doc.AddressDate)
        ipw.putData("JMBG:", ipw.doc.PersonalNumber)
        ipw.putData("Pol:", ipw.doc.Sex)

        ipw.moveY(-8.67)
        ipw.line(0)
        ipw.moveY(9)
        ipw.cell("Podaci o dokumentu")
        ipw.moveY(16)

        ipw.line(0)
        ipw.moveY(9)
        ipw.putData("Dokument izdaje:", ipw.doc.IssuingAuthority)
        ipw.putData("Broj dokumenta:", ipw.doc.DocRegNo)
        ipw.putData("Datum izdavanja:", ipw.doc.IssuingDate)
        ipw.putData("Vai do:", ipw.doc.ExpiryDate)

        ipw.moveY(-8.67)
        ipw.line(0)
        ipw.moveY(3)
        ipw.line(0)
        ipw.moveY(9)

        ipw.cell("Datum tampe: " + time.Now().Format("02.01.2006."))

        ipw.moveY(19)

        if ipw.pdf.GetY() &lt; 700 </span><span class="cov0" title="0">{
                ipw.pdf.SetY(730.6)
        }</span>

        <span class="cov8" title="1">ipw.line(0.83)

        err = ipw.pdf.SetFontSize(9)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ipw.moveY(10)
        ipw.pdf.SetX(ipw.leftMargin)

        ipw.cell("1. U ipu line karte, podaci o imenu i prezimenu imaoca line karte ispisani su na nacionalnom pismu onako kako su")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("ispisani na samom obrascu line karte, dok su ostali podaci ispisani latinikim pismom.")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("2. Ako se ime lica sastoji od dve rei ija je ukupna duina izmeu 20 i 30 karaktera ili prezimena od dve rei ija je")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("ukupna duina izmeu 30 i 36 karaktera, u ipu line karte izdate pre 18.08.2014. godine, druga re u imenu ili prezimenu")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("skrauje se na prva dva karaktera")

        ipw.moveY(15.7)
        ipw.line(0)</span>
}

func (ipw *IdPdfWriter) printForeignerId() <span class="cov0" title="0">{
        ipw.pdf.SetLineType("solid")
        ipw.pdf.SetY(59.041)
        ipw.line(0.83)

        ipw.pdf.SetXY(ipw.textLeftMargin+1.0, 64.95)

        err := ipw.pdf.SetCharSpacing(-0.2)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">ipw.cell("ITA ELEKTRONSKE LINE KARTE: TAMPA PODATAKA")

        err = ipw.pdf.SetCharSpacing(-0.1)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.pdf.SetY(79.8)

        ipw.line(0)

        imageY := 86.0
        imageHeight := 159.0

        err = ipw.pdf.ImageFrom(ipw.doc.Portrait, ipw.leftMargin, imageY, &amp;gopdf.Rect{W: 119.9, H: imageHeight})
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.pdf.SetLineWidth(0.48)
        ipw.pdf.SetFillColor(255, 255, 255)
        err = ipw.pdf.Rectangle(ipw.leftMargin, imageY, 179, imageY+imageHeight, "D", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.pdf.SetFillColor(0, 0, 0)

        ipw.pdf.SetY(250)

        ipw.line(1.08)
        ipw.moveY(8)
        ipw.pdf.SetX(ipw.textLeftMargin)
        err = ipw.pdf.SetFontSize(11.1)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.cell("Podaci o strancu")

        ipw.moveY(16)
        ipw.line(0)
        ipw.moveY(9)

        ipw.putData("Prezime:", ipw.doc.Surname)
        ipw.putData("Ime:", ipw.doc.GivenName)
        ipw.putData("Dravljanstvo:", ipw.doc.NationalityFull)
        ipw.putData("Datum roenja:", ipw.doc.DateOfBirth)
        ipw.putData("Osnov boravka:", ipw.doc.PurposeOfStay)
        addressLabel := "Prebivalite\ni adresa stana:"
        if ipw.doc.AddressLabel == "prebivalite" </span><span class="cov0" title="0">{
                addressLabel = "Prebivalite:"
        }</span>
        <span class="cov0" title="0">ipw.putData(addressLabel, localization.JoinWithComma(ipw.doc.State, ipw.doc.GetFullAddress(true)))
        ipw.putData("Datum promene adrese:", ipw.doc.AddressDate)
        ipw.putData("Evidencijski broj\nstranca:", ipw.doc.PersonalNumber)
        ipw.putData("Pol:", ipw.doc.Sex)

        ipw.moveY(-8.67)
        ipw.line(0)
        ipw.moveY(9)
        ipw.cell("Podaci o dokumentu")
        ipw.moveY(16)

        ipw.line(0)
        ipw.moveY(9)
        ipw.putData("Dokument izdaje:", ipw.doc.IssuingAuthority)
        ipw.putData("Broj dokumenta:", ipw.doc.DocRegNo)
        ipw.putData("Datum izdavanja:", ipw.doc.IssuingDate)
        ipw.putData("Vai do:", ipw.doc.ExpiryDate)

        ipw.moveY(-8.67)
        ipw.line(0)
        ipw.moveY(3)
        ipw.line(0)
        ipw.moveY(9)

        ipw.cell("Datum tampe: " + time.Now().Format("02.01.2006."))

        ipw.moveY(19)

        ipw.line(0.83)

        err = ipw.pdf.SetFontSize(9)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.moveY(4)

        ipw.pdf.SetX(ipw.leftMargin)

        ipw.cell("1. U ipu line karte za strance, podaci o imenu i prezimenu stranca ispisani su onako kako su ispisani na samom")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("obrascu line karte za stranca latininim pismom.")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("2. Ako se ime ili prezime stranca sastoji od dve ili vie rei ija duina prelazi 30 karaktera za ime, odnosno 36")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("karaktera za prezime, u ip se upisuje puno ime i prezime stranca, a na obrascu line karte za stranca se upisuje do")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("30 karaktera za ime, odnosno 36 karaktera za prezime.")

        ipw.moveY(9.7)

        ipw.line(0)</span>
}

func (ipw *IdPdfWriter) printResidencePermit() <span class="cov0" title="0">{
        ipw.pdf.SetLineType("solid")
        ipw.pdf.SetY(59.041)
        ipw.line(0.83)

        ipw.pdf.SetXY(ipw.textLeftMargin+1.0, 64.95)

        err := ipw.pdf.SetCharSpacing(-0.2)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">ipw.cell("ITA ELEKTRONSKE LINE KARTE: TAMPA PODATAKA")

        err = ipw.pdf.SetCharSpacing(-0.1)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.pdf.SetY(79.8)

        ipw.line(0)

        imageY := 86.0
        imageHeight := 159.0

        err = ipw.pdf.ImageFrom(ipw.doc.Portrait, ipw.leftMargin, imageY, &amp;gopdf.Rect{W: 119.9, H: imageHeight})
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.pdf.SetLineWidth(0.48)
        ipw.pdf.SetFillColor(255, 255, 255)
        err = ipw.pdf.Rectangle(ipw.leftMargin, imageY, 179, imageY+imageHeight, "D", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.pdf.SetFillColor(0, 0, 0)

        ipw.pdf.SetY(250)

        ipw.line(1.08)
        ipw.moveY(8)
        ipw.pdf.SetX(ipw.textLeftMargin)
        err = ipw.pdf.SetFontSize(11.1)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.cell("Podaci o strancu")

        ipw.moveY(16)
        ipw.line(0)
        ipw.moveY(9)

        ipw.putData("Prezime:", ipw.doc.Surname)
        ipw.putData("Ime:", ipw.doc.GivenName)
        ipw.putData("Dravljanstvo:", ipw.doc.NationalityFull)
        ipw.putData("Datum roenja:", ipw.doc.DateOfBirth)
        ipw.putData("Mesto roenja,\noptina i drava:", ipw.doc.GetFullPlaceOfBirth())
        addressLabel := "Prebivalite\ni adresa stana:"
        if ipw.doc.AddressLabel == "prebivalite" </span><span class="cov0" title="0">{
                addressLabel = "Prebivalite:"
        }</span>
        <span class="cov0" title="0">ipw.putData(addressLabel, ipw.doc.GetFullAddress(true))
        ipw.putData("Datum promene adrese:", ipw.doc.AddressDate)
        ipw.putData("Evidencijski broj\nstranca:", ipw.doc.PersonalNumber)
        ipw.putData("Pol:", ipw.doc.Sex)
        ipw.putData("Osnov boravka:", ipw.doc.PurposeOfStay)
        ipw.putData("Napomena:", ipw.doc.ENote)

        ipw.moveY(-8.67)
        ipw.line(0)
        ipw.moveY(9)
        ipw.cell("Podaci o dokumentu")
        ipw.moveY(16)

        ipw.line(0)
        ipw.moveY(9)
        ipw.putData("Naziv dokumenta:", ipw.doc.DocumentName)
        ipw.putData("Dokument izdaje:", ipw.doc.IssuingAuthority)
        ipw.putData("Broj dokumenta:", ipw.doc.DocRegNo)
        ipw.putData("Datum izdavanja:", ipw.doc.IssuingDate)
        ipw.putData("Vai do:", ipw.doc.ExpiryDate)

        ipw.moveY(-8.67)
        ipw.line(0)
        ipw.moveY(3)
        ipw.line(0)
        ipw.moveY(9)

        ipw.cell("Datum tampe: " + time.Now().Format("02.01.2006."))

        ipw.moveY(19)

        ipw.line(0.83)

        err = ipw.pdf.SetFontSize(9)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">ipw.moveY(4)

        ipw.pdf.SetX(ipw.leftMargin)

        ipw.cell("1. U ipu dozvole za privremeni boravak i rad, podaci o imenu i prezimenu imaoca dozvole ispisani su onako")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("kako su ispisani na samom obrascu dozvole za privremeni boravak latininim pismom.")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("2. Ako se ime ili prezime stranca sastoji od dve ili vie rei ija duina prelazi 30 karaktera za ime,")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("odnosno 36 karaktera za prezime u ip se upisuje puno ime stranca, a na obrascu dozvole za privremeni boravak")
        ipw.pdf.SetX(ipw.leftMargin)
        ipw.moveY(9.7)
        ipw.cell("se upisuje do 30 karaktera za ime, odnosno 36 karaktera za prezime.")

        ipw.moveY(9.7)

        ipw.line(0)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package document

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "image"
        "io"
        "net/http"
        "net/url"
        "regexp"
        "strings"
        "time"

        "github.com/signintech/gopdf"
        "github.com/ubavic/bas-celik/v2/localization"
)

const rfzoServiceUrl = "https://www.rfzo.rs/proveraUplateDoprinosa2.php"

// Card number doesn't have exactly 11 digits.
var ErrInvalidCardNo = errors.New("invalid card number length")

// Insurance number doesn't have exactly 11 digits.
var ErrInvalidInsuranceNo = errors.New("invalid insurance number length")

// Date `ValidUntil` could not be extracted from RFZO response.
var ErrNoSubmatchFound = errors.New("no submatch found")

// Represents a document stored on a Serbian public medical insurance card.
type MedicalDocument struct {
        InsurerName            string
        InsurerID              string
        CardId                 string
        DateOfIssue            string
        DateOfExpiry           string
        ChipSerialNumber       string
        PrintLanguage          string
        PersonalNumber         string
        FamilyNameLatin        string
        GivenNameLatin         string
        ParentNameLatin        string
        FamilyName             string
        GivenName              string
        ParentName             string
        Gender                 string
        InsurantNumber         string
        DateOfBirth            string
        Apartment              string
        Number                 string
        Street                 string
        Place                  string
        Municipality           string
        Country                string
        ValidUntil             string
        PermanentlyValid       bool
        CarrierGivenNameLatin  string
        CarrierFamilyNameLatin string
        CarrierGivenName       string
        CarrierFamilyName      string
        CarrierIdNumber        string
        CarrierInsurantNumber  string
        CarrierFamilyMember    bool
        CarrierRelationship    string
        InsuranceBasisRZZO     string
        InsuranceStartDate     string
        InsuranceDescription   string
        TaxpayerName           string
        TaxpayerResidence      string
        TaxpayerNumber         string
        TaxpayerIdNumber       string
        TaxpayerActivityCode   string
}

func (doc *MedicalDocument) GetFullName() string <span class="cov8" title="1">{
        return localization.JoinWithComma(doc.GivenNameLatin, doc.ParentNameLatin, doc.FamilyNameLatin)
}</span>

func (doc *MedicalDocument) GetFullStreetAddress() string <span class="cov8" title="1">{
        var address strings.Builder

        address.WriteString(doc.Street)
        if len(doc.Number) &gt; 0 </span><span class="cov8" title="1">{
                address.WriteString(", : ")
                address.WriteString(doc.Number)
        }</span>

        <span class="cov8" title="1">if len(doc.Apartment) &gt; 0 </span><span class="cov8" title="1">{
                address.WriteString(" : ")
                address.WriteString(doc.Apartment)
        }</span>

        <span class="cov8" title="1">return address.String()</span>
}

func (doc *MedicalDocument) GetFullPlaceAddress() string <span class="cov8" title="1">{
        return localization.JoinWithComma(doc.Place, doc.Municipality, doc.Country)
}</span>

func (doc *MedicalDocument) BuildPdf() (data []byte, fileName string, retErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        switch x := r.(type) </span>{
                        case error:<span class="cov0" title="0">
                                retErr = x</span>
                        default:<span class="cov0" title="0">
                                retErr = errors.New("unknown panic")</span>
                        }
                }
        }()

        <span class="cov8" title="1">pdf := gopdf.GoPdf{}
        pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4})

        pdf.AddPage()

        err := pdf.AddTTFFontData("liberationsans", fontRegular)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("loading font: %w", err))</span>
        }

        <span class="cov8" title="1">err = pdf.SetFont("liberationsans", "", 11)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("setting font: %w", err))</span>
        }

        <span class="cov8" title="1">const leftMargin = 30.464
        const rightMargin = 535
        const textLeftMargin = 38.243

        cell := func(s string) </span><span class="cov8" title="1">{
                err := pdf.Cell(nil, s)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("putting text: %w", err))</span>
                }
        }

        <span class="cov8" title="1">section := func(name string) </span><span class="cov8" title="1">{
                y := pdf.GetY() + 8
                pdf.Line(leftMargin, y, rightMargin, y)
                pdf.SetXY(textLeftMargin, y+12)
                cell(name)
                pdf.Line(leftMargin, y+32, rightMargin, y+32)
                pdf.SetXY(textLeftMargin, y+41)
        }</span>

        <span class="cov8" title="1">putData := func(label, data string) </span><span class="cov8" title="1">{
                cell(label)
                pdf.SetXY(textLeftMargin+144, pdf.GetY())

                texts, err := pdf.SplitTextWithWordWrap(data, 350)
                if err != nil &amp;&amp; err != gopdf.ErrEmptyString </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("splitting text: %w", err))</span>
                }

                <span class="cov8" title="1">for i, text := range texts </span><span class="cov8" title="1">{
                        cell(text)
                        if i &lt; len(texts)-1 </span><span class="cov0" title="0">{
                                pdf.SetXY(textLeftMargin+144, pdf.GetY()+11)
                        }</span>
                }

                <span class="cov8" title="1">pdf.SetXY(textLeftMargin, pdf.GetY()+14)</span>
        }

        <span class="cov8" title="1">pdf.SetLineWidth(0.58)
        pdf.SetLineType("solid")

        rfzoLogoImage, _, err := image.Decode(bytes.NewReader(rfzoLogo))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("decoding photo file: %w", err))</span>
        }

        <span class="cov8" title="1">err = pdf.ImageFrom(rfzoLogoImage, 36.0, 14.0, &amp;gopdf.Rect{W: 144, H: 51})
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("inserting logo: %w", err))</span>
        }

        <span class="cov8" title="1">pdf.SetXY(218.6, 49.6)
        cell("    ()")

        pdf.SetY(68)
        section("   ")

        putData(":", doc.GivenName+" ("+doc.GivenNameLatin+")")

        putData("  :", doc.ParentName+" ("+doc.ParentNameLatin+")")

        putData(":", doc.FamilyName+" ("+doc.FamilyNameLatin+")")

        putData(" :", doc.DateOfBirth)

        putData(",   :", doc.GetFullPlaceAddress())

        putData(":", doc.GetFullStreetAddress())

        putData(":", doc.Gender)

        putData(":", doc.PrintLanguage)

        putData(":", doc.InsurantNumber)

        putData(":", doc.PersonalNumber)

        section("    ")

        putData(" :", doc.DateOfIssue)

        putData(" :", doc.DateOfExpiry)

        putData(" :", doc.ValidUntil)

        putData(" :", localization.FormatYesNo(doc.PermanentlyValid, localization.SrCyrillic))

        section("   ")

        putData(":", doc.CarrierGivenName+" ("+doc.CarrierGivenNameLatin+")")

        putData(":", doc.CarrierFamilyName+" ("+doc.CarrierFamilyName+")")

        putData(":", doc.CarrierInsurantNumber)

        putData(":", doc.CarrierIdNumber)

        putData(" :", localization.FormatYesNo(doc.CarrierFamilyMember, localization.SrCyrillic))

        putData(":", doc.CarrierRelationship)

        section("  ")

        putData(" :", doc.InsuranceBasisRZZO)

        putData("  :", doc.InsuranceStartDate)

        putData(":", doc.InsuranceDescription)

        section("    ")

        putData(":", doc.TaxpayerName)

        putData(":", doc.TaxpayerResidence)

        putData(" :", doc.TaxpayerNumber)

        putData("/:", doc.TaxpayerIdNumber)

        putData(":", doc.TaxpayerActivityCode)

        fileName = doc.formatFilename() + ".pdf"

        pdf.SetInfo(gopdf.PdfInfo{
                Title:        doc.GivenNameLatin + " " + doc.FamilyNameLatin,
                Author:       "Ba elik",
                Subject:      "Lina karta",
                CreationDate: time.Now(),
        })

        return pdf.GetBytesPdf(), fileName, nil</span>
}

func (doc *MedicalDocument) BuildJson() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(doc)
}</span>

func (doc *MedicalDocument) BuildExcel() ([]byte, string, error) <span class="cov0" title="0">{
        xlsx, err := CreateExcel(*doc)
        name := doc.formatFilename() + ".xlsx"
        return xlsx, name, err
}</span>

func (doc *MedicalDocument) formatFilename() string <span class="cov8" title="1">{
        return strings.ToLower(doc.GivenNameLatin + "_" + doc.FamilyNameLatin)
}</span>

func (doc *MedicalDocument) UpdateValidUntilDateFromRfzo() error <span class="cov8" title="1">{
        if len([]rune(doc.CardId)) != 11 </span><span class="cov8" title="1">{
                return ErrInvalidCardNo
        }</span>

        <span class="cov8" title="1">if len([]rune(doc.InsurantNumber)) != 11 </span><span class="cov8" title="1">{
                return ErrInvalidInsuranceNo
        }</span>

        <span class="cov0" title="0">resp, err := http.PostForm(rfzoServiceUrl, url.Values{"zk": {doc.CardId}, "lbo": {doc.InsurantNumber}})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("posting: %w", err)
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading response body: %w", err)
        }</span>

        <span class="cov0" title="0">date, err := ParseValidUntilDateFromRfzoResponse(string(body))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing response: %w", err)
        }</span>

        <span class="cov0" title="0">doc.ValidUntil = date

        return nil</span>
}

func ParseValidUntilDateFromRfzoResponse(response string) (string, error) <span class="cov8" title="1">{
        regex, err := regexp.Compile(` : &lt;strong&gt;(\d+\.\d+\.\d+\.)&lt;/strong&gt;`)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("compiling regex: %w", err)
        }</span>

        <span class="cov8" title="1">matches := regex.FindStringSubmatch(response)
        if len(matches) &lt; 2 </span><span class="cov8" title="1">{
                return "", ErrNoSubmatchFound
        }</span>

        <span class="cov8" title="1">return matches[1], nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package document

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/signintech/gopdf"
)

// Represents a document stored on a Serbian vehicle card.
// Fields are named according to official API.
type VehicleDocument struct {
        AuthorityIssuing            string
        ColourOfVehicle             string
        CommercialDescription       string
        CompetentAuthority          string
        DateOfFirstRegistration     string
        EngineCapacity              string
        EngineIdNumber              string
        EngineRatedSpeed            string
        ExpiryDate                  string
        HomologationMark            string
        IssuingDate                 string
        MaximumNetPower             string
        MaximumPermissibleLadenMass string
        NumberOfAxles               string
        NumberOfSeats               string
        NumberOfStandingPlaces      string
        OwnerAddress                string
        OwnerName                   string
        OwnersPersonalNo            string
        OwnersSurnameOrBusinessName string
        PowerWeightRatio            string
        RegistrationNumberOfVehicle string
        SerialNumber                string
        StateIssuing                string
        TypeApprovalNumber          string
        TypeOfFuel                  string
        UnambiguousNumber           string
        UsersAddress                string
        UsersName                   string
        UsersPersonalNo             string
        UsersSurnameOrBusinessName  string
        VehicleCategory             string
        VehicleIdNumber             string
        VehicleLoad                 string
        VehicleMake                 string
        VehicleMass                 string
        VehicleType                 string
        YearOfProduction            string
}

func (doc *VehicleDocument) BuildPdf() (data []byte, fileName string, retErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        switch x := r.(type) </span>{
                        case error:<span class="cov8" title="1">
                                retErr = x</span>
                        default:<span class="cov0" title="0">
                                retErr = errors.New("unknown panic")</span>
                        }
                }
        }()

        <span class="cov8" title="1">pdf := gopdf.GoPdf{}
        pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4})

        pdf.AddPage()

        err := pdf.AddTTFFontData("liberationsans", fontRegular)
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Errorf("loading font: %w", err))</span>
        }

        <span class="cov8" title="1">err = pdf.AddTTFFontDataWithOption("liberationsans", fontBold, gopdf.TtfOption{Style: gopdf.Bold})
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("loading font: %w", err))</span>
        }

        <span class="cov8" title="1">const leftMargin = 28
        const rightMargin = 535
        const textLeftMargin = 38

        underlineOption := gopdf.CellOption{CoefUnderlineThickness: 1, CoefUnderlinePosition: -2}

        newLine := func() </span><span class="cov8" title="1">{
                pdf.SetXY(textLeftMargin, pdf.GetY()+20)
        }</span>

        <span class="cov8" title="1">tab := func() </span><span class="cov8" title="1">{
                pdf.SetXY(343, pdf.GetY())
        }</span>

        <span class="cov8" title="1">dashFormat := func(str string) string </span><span class="cov8" title="1">{
                if len(str) == 0 </span><span class="cov8" title="1">{
                        return "-"
                }</span> else<span class="cov0" title="0"> {
                        return str
                }</span>
        }

        <span class="cov8" title="1">cell := func(s string) </span><span class="cov8" title="1">{
                err := pdf.Cell(nil, s)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("putting text: %w", err))</span>
                }
        }

        <span class="cov8" title="1">putData := func(label, data string) </span><span class="cov8" title="1">{
                cell(label + ": " + data)
        }</span>

        <span class="cov8" title="1">putUnderline := func(str string, size int) </span><span class="cov8" title="1">{
                err = pdf.SetFont("liberationsans", "U", size)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("setting font: %w", err))</span>
                }
                <span class="cov8" title="1">err = pdf.CellWithOption(nil, str, underlineOption)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("cell: %w", err))</span>
                }
                <span class="cov8" title="1">err = pdf.SetFont("liberationsans", "B", 12)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("setting font: %w", err))</span>
                }
        }

        <span class="cov8" title="1">putParagraph := func(data string) </span><span class="cov8" title="1">{

                texts := strings.Split(data, ",")
                if len(texts) == 2 </span><span class="cov8" title="1">{
                        cell(texts[0] + ",")
                        pdf.SetXY(textLeftMargin, pdf.GetY()+14)
                        cell(strings.TrimSpace(texts[1]))
                        pdf.SetXY(textLeftMargin, pdf.GetY()+20)
                        return
                }</span>

                <span class="cov0" title="0">texts, err = pdf.SplitTextWithWordWrap(data, 500)
                if err != nil &amp;&amp; err != gopdf.ErrEmptyString </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("splitting text: %w", err))</span>
                }

                <span class="cov0" title="0">for i, text := range texts </span><span class="cov0" title="0">{
                        cell(text)
                        if i &lt; len(texts)-1 </span><span class="cov0" title="0">{
                                pdf.SetXY(textLeftMargin, pdf.GetY()+14)
                        }</span>
                }

                <span class="cov0" title="0">pdf.SetXY(textLeftMargin, pdf.GetY()+20)</span>
        }

        <span class="cov8" title="1">err = pdf.SetFont("liberationsans", "B", 29)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("setting font: %w", err))</span>
        }
        <span class="cov8" title="1">pdf.SetXY(textLeftMargin, 35)
        cell("ita saobraajne dozvole")

        pdf.SetLineWidth(2.9)
        pdf.SetLineType("solid")
        pdf.Line(leftMargin, 72, rightMargin, 72)

        pdf.SetXY(textLeftMargin, 90)
        err = pdf.SetFontSize(21)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("setting font size: %w", err))</span>
        }
        <span class="cov8" title="1">cell("Registarska oznaka: " + doc.RegistrationNumberOfVehicle)

        pdf.SetXY(textLeftMargin, 145)
        err = pdf.SetFontSize(12)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("setting font: %w", err))</span>
        }

        <span class="cov8" title="1">putData("Datum izdavanja", doc.IssuingDate)
        tab()
        putUnderline("Vai do: "+doc.ExpiryDate, 12)
        newLine()

        putData("Saobraajnu izdao", doc.StateIssuing)
        tab()
        putData("Zabrana otuenja", "")
        newLine()
        putParagraph(doc.AuthorityIssuing + ",\n" + doc.CompetentAuthority)

        putData("Broj saobraajne", doc.UnambiguousNumber)
        newLine()

        putData("Serijski broj", doc.SerialNumber)
        newLine()

        pdf.SetXY(textLeftMargin, 272)
        putUnderline("Podaci o vlasniku", 20)
        pdf.SetXY(textLeftMargin, pdf.GetY()+25)

        putData("Vlasnik", doc.OwnersSurnameOrBusinessName)
        newLine()

        putData("Ime vlasnika", doc.OwnerName)
        newLine()

        putData("Adresa vlasnika", doc.OwnerAddress)
        newLine()

        putData("Jmbg vlasnika", doc.OwnersPersonalNo)
        newLine()

        putData("Korisnik", doc.UsersSurnameOrBusinessName)
        newLine()

        putData("Ime korisnika", doc.UsersName)
        newLine()

        putData("Adresa korisnika", doc.UsersAddress)
        newLine()

        putData("Jmbg korisnika", doc.UsersPersonalNo)
        newLine()

        pdf.SetXY(textLeftMargin, pdf.GetY()+6)
        putUnderline("Podaci o vozilu", 20)
        pdf.SetXY(textLeftMargin, pdf.GetY()+25)

        putData("Datum prve registracije", doc.DateOfFirstRegistration)
        tab()
        putData("Godina proizvodnje", doc.YearOfProduction)
        newLine()

        putData("Marka", doc.VehicleMake)
        pdf.SetXY(pdf.GetX()+10, pdf.GetY())
        putData("Model", doc.CommercialDescription)
        newLine()

        putData("Tip", dashFormat(doc.VehicleType))
        pdf.SetXY(pdf.GetX()+10, pdf.GetY())
        putData("Homologacijska oznaka", dashFormat(doc.HomologationMark))
        newLine()

        putData("Boja", doc.ColourOfVehicle)
        tab()
        putData("Broj osovina", doc.NumberOfAxles)
        newLine()

        putData("Broj asije", doc.VehicleIdNumber)
        tab()
        putData("Zapremina motora", doc.EngineCapacity)
        newLine()

        putData("Broj motora", doc.EngineIdNumber)
        tab()
        putData("Masa", doc.VehicleMass)
        newLine()

        putData("Snaga motora", doc.MaximumNetPower)
        tab()
        putData("Nosivost", doc.VehicleLoad)
        newLine()

        putData("Odnos snaga/masa", doc.PowerWeightRatio)
        tab()
        cell("Najvea dozvoljena")
        newLine()

        putData("Kategorija", doc.VehicleCategory)
        tab()
        putData("masa", doc.MaximumPermissibleLadenMass)
        newLine()

        putData("Pogonsko gorivo", doc.TypeOfFuel)
        newLine()

        putData("Broj mesta za sedenje", doc.NumberOfSeats)
        tab()
        putData("Broj mesta za stajanje", doc.NumberOfStandingPlaces)
        newLine()

        fileName = doc.formatFilename() + ".pdf"

        pdf.SetInfo(gopdf.PdfInfo{
                Title:        doc.VehicleMake + " " + doc.CommercialDescription,
                Author:       "Ba elik",
                Subject:      "Saobraajna dozvola",
                CreationDate: time.Now(),
        })

        return pdf.GetBytesPdf(), fileName, nil</span>
}

func (doc *VehicleDocument) BuildJson() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(doc)
}</span>

func (doc *VehicleDocument) BuildExcel() ([]byte, string, error) <span class="cov0" title="0">{
        xlsx, err := CreateExcel(*doc)
        fileName := doc.formatFilename() + ".xlsx"
        return xlsx, fileName, err
}</span>

func (doc *VehicleDocument) formatFilename() string <span class="cov8" title="1">{
        return strings.ToLower(doc.RegistrationNumberOfVehicle + "_" + doc.OwnersSurnameOrBusinessName + "_" + doc.OwnerName)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package internal

import (
        "encoding/hex"
        "flag"
        "fmt"
        "strings"

        "github.com/ebfe/scard"
)

var version string

func ProcessFlags() (LaunchConfig, bool) <span class="cov0" title="0">{
        launchCfg := LaunchConfig{}

        atrFlag := flag.Bool("atr", false, "Print the ATR form the card and exit")
        excelPath := flag.String("excel", "", "Set Excel export path")
        jsonPath := flag.String("json", "", "Set JSON export path")
        listFlag := flag.Bool("list", false, "List connected readers and exit")
        pdfPath := flag.String("pdf", "", "Set PDF export path.")
        getValidUntilFromRfzo := flag.Bool("rfzoValidUntil", false, "Get the valid until date of medical card insurance from the RFZO API. Ignored for other cards")
        verboseFlag := flag.Bool("verbose", false, "Provide additional details in the terminal")
        versionFlag := flag.Bool("version", false, "Display version information and exit")
        readerIndex := flag.Uint("reader", 0, "Set reader")
        flag.Parse()

        if *versionFlag </span><span class="cov0" title="0">{
                printVersion()
                return launchCfg, true
        }</span>

        <span class="cov0" title="0">if *listFlag </span><span class="cov0" title="0">{
                err := listReaders()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error reading ATR:", err)
                }</span>
                <span class="cov0" title="0">return launchCfg, true</span>
        }

        <span class="cov0" title="0">if *atrFlag </span><span class="cov0" title="0">{
                err := printATR(*readerIndex)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error reading ATR:", err)
                }</span>
                <span class="cov0" title="0">return launchCfg, true</span>
        }

        <span class="cov0" title="0">launchCfg.JsonPath = *jsonPath
        launchCfg.PdfPath = *pdfPath
        launchCfg.ExcelPath = *excelPath
        launchCfg.Verbose = *verboseFlag
        launchCfg.Reader = *readerIndex
        launchCfg.GetValidUntilFromRfzo = *getValidUntilFromRfzo

        return launchCfg, false</span>
}

func printATR(reader uint) error <span class="cov0" title="0">{
        ctx, err := scard.EstablishContext()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("establishing context: %w", err)
        }</span>

        <span class="cov0" title="0">defer ctx.Release()

        readersNames, err := ctx.ListReaders()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("listing readers: %w", err)
        }</span>

        <span class="cov0" title="0">if len(readersNames) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no reader found")
        }</span>

        <span class="cov0" title="0">if reader &gt;= uint(len(readersNames)) </span><span class="cov0" title="0">{
                return fmt.Errorf("only %d readers found", len(readersNames))
        }</span>

        <span class="cov0" title="0">sCard, err := ctx.Connect(readersNames[reader], scard.ShareShared, scard.ProtocolAny)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connecting reader %s: %w", readersNames[reader], err)
        }</span>

        <span class="cov0" title="0">defer sCard.Disconnect(scard.LeaveCard)

        smartCardStatus, err := sCard.Status()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading card %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println(hex.EncodeToString(smartCardStatus.Atr))

        return nil</span>
}

func listReaders() error <span class="cov0" title="0">{
        ctx, err := scard.EstablishContext()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("establishing context: %w", err)
        }</span>

        <span class="cov0" title="0">defer ctx.Release()

        readersNames, err := ctx.ListReaders()
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "scard: Cannot find a smart card reader." </span><span class="cov0" title="0">{
                        fmt.Println("No readers found.")
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("listing readers: %w", err)</span>
        }

        <span class="cov0" title="0">if len(readersNames) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No readers found.")
                return nil
        }</span>

        <span class="cov0" title="0">for i, name := range readersNames </span><span class="cov0" title="0">{
                fmt.Println(i, "|", name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func printVersion() <span class="cov0" title="0">{
        ver := strings.TrimSpace(version)
        fmt.Println("bas-celik", ver)
        fmt.Println("https://github.com/ubavic/bas-celik")
}</span>

func SetVersion(v string) <span class="cov0" title="0">{
        version = v
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package gui

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func showAboutBox() func() <span class="cov0" title="0">{
        version := strings.TrimSpace(state.version)

        verLabel := widget.NewLabelWithStyle(t("about.version")+": "+version, fyne.TextAlignLeading, fyne.TextStyle{Italic: true})
        moreLabel := widget.NewLabel(t("about.moreAboutProgram"))
        url, _ := url.Parse("https://github.com/ubavic/bas-celik")
        linkLabel := widget.NewHyperlink("github.com/ubavic/bas-celik", url)
        spacer := widgets.NewSpacer()
        verButton := widget.NewButton(t("about.checkVersion"), func() </span><span class="cov0" title="0">{
                newVersion, err := checkForUpdate()
                if err != nil || newVersion == "" </span><span class="cov0" title="0">{
                        logger.Error(err)
                        return
                }</span>

                <span class="cov0" title="0">if newVersion != "v"+version </span><span class="cov0" title="0">{
                        dialog.ShowInformation(t("about.version"), fmt.Sprintf(t("about.newVersionAvailable"), newVersion), state.window)
                }</span> else<span class="cov0" title="0"> {
                        dialog.ShowInformation(t("about.version"), t("about.youHaveLatestVersion"), state.window)
                }</span>
        })

        <span class="cov0" title="0">hBox0 := container.NewHBox(verLabel, verButton)
        hBox1 := container.NewHBox(moreLabel, linkLabel)
        vBox := container.NewVBox(hBox0, hBox1, spacer)

        return func() </span><span class="cov0" title="0">{
                dialog.ShowCustom(
                        t("about.title"),
                        t("about.close"),
                        vBox,
                        state.window,
                )
        }</span>
}

func checkForUpdate() (string, error) <span class="cov0" title="0">{
        client := http.Client{
                Timeout: time.Second,
        }

        url := `https://api.github.com/repos/ubavic/bas-celik/releases/latest`
        req, err := http.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("creating request: %w", err)
        }</span>

        <span class="cov0" title="0">res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("executing request: %w", err)
        }</span>

        <span class="cov0" title="0">if res.Body != nil </span><span class="cov0" title="0">{
                defer res.Body.Close()
        }</span>

        <span class="cov0" title="0">response := struct {
                TagName string `json:"tag_name"`
        }{}
        err = json.NewDecoder(res.Body).Decode(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("decoding response: %w", err)
        }</span>

        <span class="cov0" title="0">return response.TagName, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package gui

import (
        "fmt"
        "time"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/internal/gui/reader"
        "github.com/ubavic/bas-celik/v2/internal/gui/translation"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func startCardReaderUI() <span class="cov0" title="0">{
        widgets.SetClipboard(copyToClipboard)

        spacer := widgets.NewSpacer()

        poller, pollerErr := reader.NewPoller(state.toolbar, connectToCard)

        rows := container.New(layout.NewVBoxLayout(), state.toolbar, spacer, state.startPage, state.documentUiMainContainer, state.cryptoUiContainer)
        columns := container.New(layout.NewHBoxLayout(), layout.NewSpacer(), rows, layout.NewSpacer())

        state.documentUi = columns

        state.mainContainer.Add(state.documentUi)

        state.cryptoUiContainer.Hide()

        if pollerErr == nil </span><span class="cov0" title="0">{
                poller.StartPoller()
        }</span> else<span class="cov0" title="0"> {
                setStartPage("error.contextFail", "", pollerErr)
        }</span>

        <span class="cov0" title="0">state.window.ShowAndRun()</span>
}

func setUI(doc document.Document) <span class="cov0" title="0">{
        state.mu.Lock()
        defer state.mu.Unlock()

        var page *fyne.Container
        buttonBarObjects := []fyne.CanvasObject{state.statusBar, layout.NewSpacer()}

        switch doc := doc.(type) </span>{
        case *document.IdDocument:<span class="cov0" title="0">
                page = pageID(doc)</span>
        case *document.MedicalDocument:<span class="cov0" title="0">
                updateButton := widget.NewButton(t("ui.update"), updateMedicalDocHandler(doc))
                buttonBarObjects = append(buttonBarObjects, updateButton)
                page = pageMedical(doc)</span>
        case *document.VehicleDocument:<span class="cov0" title="0">
                page = pageVehicle(doc)</span>
        }

        <span class="cov0" title="0">savePdfButton := widget.NewButton(t("ui.savePdf"), savePdf(doc))
        saveXlsxButton := widget.NewButton(t("ui.saveXlsx"), saveXlsx(doc))
        buttonBarObjects = append(buttonBarObjects, saveXlsxButton, savePdfButton)

        buttonBar := container.New(layout.NewHBoxLayout(), buttonBarObjects...)

        state.documentUiMainContainer.RemoveAll()
        state.documentUiMainContainer.Add(page)
        state.documentUiMainContainer.Add(buttonBar)

        state.startPage.Hide()
        state.documentUiMainContainer.Show()

        resizeWindow(false)</span>
}

func setStartPage(statusId, explanationId string, err error) <span class="cov0" title="0">{
        state.mu.Lock()
        defer state.mu.Unlock()

        status := t(statusId)
        explanation := t(explanationId)

        isError := false
        if err != nil </span><span class="cov0" title="0">{
                isError = true
        }</span>

        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                logger.Error(err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info(translation.EnglishTranslation(statusId) + " " + translation.EnglishTranslation(explanationId))
        }</span>

        <span class="cov0" title="0">state.startPage.SetStatus(status, explanation, isError)
        state.startPage.Refresh()

        state.documentUiMainContainer.RemoveAll()

        state.documentUiMainContainer.Hide()
        state.startPage.Show()

        resizeWindow(true)</span>
}

func setStatus(statusId string, err error) <span class="cov0" title="0">{
        isError := false
        if err != nil </span><span class="cov0" title="0">{
                isError = true
        }</span>

        <span class="cov0" title="0">if isError </span><span class="cov0" title="0">{
                logger.Error(err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info(translation.EnglishTranslation(statusId))
        }</span>

        <span class="cov0" title="0">status := t(statusId)
        state.statusBar.SetStatus(status, isError)
        state.statusBar.Refresh()</span>
}

func updateMedicalDocHandler(doc *document.MedicalDocument) func() <span class="cov0" title="0">{
        return func() </span><span class="cov0" title="0">{
                err := doc.UpdateValidUntilDateFromRfzo()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(fmt.Errorf("updating medical information: %w", err))
                        dialog.ShowInformation(t("error.error"), t("error.dataUpdate"), state.window)
                        return
                }</span>

                <span class="cov0" title="0">setStatus("ui.updateSuccessful", nil)
                setUI(doc)</span>
        }
}

func copyToClipboard(str string) bool <span class="cov0" title="0">{
        if state.window == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">clipboard := state.window.Clipboard()
        if clipboard == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">label := t("ui.contentCopied")

        clipboard.SetContent(str)
        setTimedStatus(label)

        return true</span>
}

func setTimedStatus(label string) <span class="cov0" title="0">{
        state.statusBar.SetStatus(label, false)
        state.statusBar.Refresh()
        go func() </span><span class="cov0" title="0">{
                time.Sleep(2 * time.Second)
                if state.statusBar.GetStatus() == label </span><span class="cov0" title="0">{
                        state.statusBar.SetStatus("", false)
                        state.statusBar.Refresh()
                }</span>
        }()
}

func showDocumentUI() <span class="cov0" title="0">{
        state.mainContainer.RemoveAll()
        state.mainContainer.Add(state.documentUi)
}</span>

func resizeWindow(keepCurrentSize bool) <span class="cov0" title="0">{
        minSize := state.documentUi.MinSize()

        if keepCurrentSize </span><span class="cov0" title="0">{
                currentSize := state.mainContainer.Size()

                if currentSize.Height &gt; minSize.Height </span><span class="cov0" title="0">{
                        minSize.Height = currentSize.Height
                }</span>

                <span class="cov0" title="0">if currentSize.Width &gt; minSize.Width </span><span class="cov0" title="0">{
                        minSize.Width = currentSize.Width
                }</span>
        }

        <span class="cov0" title="0">state.window.Resize(minSize)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package celiktheme

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/theme"
)

type Theme struct {
        systemDecides bool
        dark          bool
}

func NewTheme(themeSelection int) Theme <span class="cov0" title="0">{
        theme := Theme{}

        if themeSelection &lt;= 0 </span><span class="cov0" title="0">{
                theme.systemDecides = true
        }</span> else<span class="cov0" title="0"> if themeSelection == 2 </span><span class="cov0" title="0">{
                theme.dark = true
        }</span>

        <span class="cov0" title="0">return theme</span>
}

func (t Theme) Color(colorName fyne.ThemeColorName, v fyne.ThemeVariant) color.Color <span class="cov0" title="0">{
        if t.systemDecides </span><span class="cov0" title="0">{
                if v == theme.VariantLight || v == 2 </span><span class="cov0" title="0">{
                        return lightTheme(colorName)
                }</span> else<span class="cov0" title="0"> {
                        return darkTheme(colorName)
                }</span>
        } else<span class="cov0" title="0"> if t.dark </span><span class="cov0" title="0">{
                return darkTheme(colorName)
        }</span> else<span class="cov0" title="0"> {
                return lightTheme(colorName)
        }</span>
}

func (Theme) Font(s fyne.TextStyle) fyne.Resource <span class="cov0" title="0">{
        return theme.DefaultTheme().Font(s)
}</span>

func (Theme) Icon(n fyne.ThemeIconName) fyne.Resource <span class="cov0" title="0">{
        return theme.DefaultTheme().Icon(n)
}</span>

func (Theme) Size(s fyne.ThemeSizeName) float32 <span class="cov0" title="0">{
        return theme.DefaultTheme().Size(s)
}</span>

func (Theme) CornerRadius() float32 <span class="cov0" title="0">{
        return 3
}</span>

func lightTheme(c fyne.ThemeColorName) color.Color <span class="cov0" title="0">{
        switch c </span>{
        case theme.ColorNameBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0xFF, G: 0xFF, B: 0xFF, A: 0xFF}</span>
        case theme.ColorNameButton:<span class="cov0" title="0">
                return color.NRGBA{R: 0xF0, G: 0xF0, B: 0xF0, A: 0xFF}</span>
        case theme.ColorNameDisabledButton:<span class="cov0" title="0">
                return color.NRGBA{R: 0xD0, G: 0xD0, B: 0xD0, A: 0xFF}</span>
        case theme.ColorNameDisabled:<span class="cov0" title="0">
                return color.NRGBA{R: 0x60, G: 0x60, B: 0x60, A: 0xFF}</span>
        case theme.ColorNameError:<span class="cov0" title="0">
                return color.NRGBA{R: 0xF0, G: 0x47, B: 0x3B, A: 0xFF}</span>
        case theme.ColorNameFocus:<span class="cov0" title="0">
                return color.NRGBA{R: 0xDE, G: 0xEB, B: 0xFA, A: 0xFF}</span>
        case theme.ColorNameForeground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x21, G: 0x21, B: 0x21, A: 0xFF}</span>
        case theme.ColorNameForegroundOnPrimary:<span class="cov0" title="0">
                return color.NRGBA{R: 0xFF, G: 0xFF, B: 0xFF, A: 0xFF}</span>
        case theme.ColorNameHeaderBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x21, G: 0x21, B: 0x21, A: 0xFF}</span>
        case theme.ColorNameHover:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x40, A: 0x10}</span>
        case theme.ColorNameHyperlink:<span class="cov0" title="0">
                return color.NRGBA{R: 0x50, G: 0x50, B: 0xA0, A: 0xFF}</span>
        case theme.ColorNameInputBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0xF0, G: 0xF0, B: 0xF0, A: 0xFF}</span>
        case theme.ColorNameInputBorder:<span class="cov0" title="0">
                return color.NRGBA{R: 0xDA, G: 0xDA, B: 0xDA, A: 0xFF}</span>
        case theme.ColorNameMenuBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0xFF, G: 0xFF, B: 0xFF, A: 0xFF}</span>
        case theme.ColorNameOverlayBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0xF9, G: 0xF9, B: 0xF9, A: 0xFF}</span>
        case theme.ColorNamePlaceHolder:<span class="cov0" title="0">
                return color.NRGBA{R: 0x88, G: 0x88, B: 0x88, A: 0xFF}</span>
        case theme.ColorNamePressed:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x00}</span>
        case theme.ColorNamePrimary:<span class="cov0" title="0">
                return color.NRGBA{R: 0x5A, G: 0x73, B: 0x8F, A: 0xFF}</span>
        case theme.ColorNameScrollBar:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x99}</span>
        case theme.ColorNameSelection:<span class="cov0" title="0">
                return color.NRGBA{R: 0xDE, G: 0xEB, B: 0xFA, A: 0xFF}</span>
        case theme.ColorNameShadow:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x10}</span>
        default:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x10}</span>
        }
}

func darkTheme(c fyne.ThemeColorName) color.Color <span class="cov0" title="0">{
        switch c </span>{
        case theme.ColorNameBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x10, G: 0x10, B: 0x13, A: 0xFF}</span>
        case theme.ColorNameButton:<span class="cov0" title="0">
                return color.NRGBA{R: 0x20, G: 0x20, B: 0x20, A: 0xFF}</span>
        case theme.ColorNameDisabledButton:<span class="cov0" title="0">
                return color.NRGBA{R: 0x12, G: 0x12, B: 0x12, A: 0xFF}</span>
        case theme.ColorNameDisabled:<span class="cov0" title="0">
                return color.NRGBA{R: 0x40, G: 0x40, B: 0x40, A: 0xFF}</span>
        case theme.ColorNameError:<span class="cov0" title="0">
                return color.NRGBA{R: 0xF0, G: 0x47, B: 0x3B, A: 0xFF}</span>
        case theme.ColorNameFocus:<span class="cov0" title="0">
                return color.NRGBA{R: 0x23, G: 0x20, B: 0x24, A: 0xFF}</span>
        case theme.ColorNameForeground:<span class="cov0" title="0">
                return color.NRGBA{R: 0xD0, G: 0xD0, B: 0xD0, A: 0xFF}</span>
        case theme.ColorNameForegroundOnPrimary:<span class="cov0" title="0">
                return color.NRGBA{R: 0xD9, G: 0xD0, B: 0xD0, A: 0xFF}</span>
        case theme.ColorNameHeaderBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x21, G: 0x21, B: 0x21, A: 0xFF}</span>
        case theme.ColorNameHover:<span class="cov0" title="0">
                return color.NRGBA{R: 0xFF, G: 0xFF, B: 0xFF, A: 0x10}</span>
        case theme.ColorNameHyperlink:<span class="cov0" title="0">
                return color.NRGBA{R: 0x80, G: 0x90, B: 0xF0, A: 0xFF}</span>
        case theme.ColorNameInputBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x20, G: 0x20, B: 0x20, A: 0xFF}</span>
        case theme.ColorNameInputBorder:<span class="cov0" title="0">
                return color.NRGBA{R: 0xDA, G: 0xDA, B: 0xDA, A: 0x00}</span>
        case theme.ColorNameMenuBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x15, G: 0x15, B: 0x15, A: 0xFF}</span>
        case theme.ColorNameOverlayBackground:<span class="cov0" title="0">
                return color.NRGBA{R: 0x15, G: 0x15, B: 0x17, A: 0xFF}</span>
        case theme.ColorNamePlaceHolder:<span class="cov0" title="0">
                return color.NRGBA{R: 0x88, G: 0x88, B: 0x88, A: 0xFF}</span>
        case theme.ColorNamePressed:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x00}</span>
        case theme.ColorNamePrimary:<span class="cov0" title="0">
                return color.NRGBA{R: 0x41, G: 0x4D, B: 0x7A, A: 0xFF}</span>
        case theme.ColorNameScrollBar:<span class="cov0" title="0">
                return color.NRGBA{R: 0xFF, G: 0xFF, B: 0xFF, A: 0x50}</span>
        case theme.ColorNameSelection:<span class="cov0" title="0">
                return color.NRGBA{R: 0x23, G: 0x20, B: 0x24, A: 0xFF}</span>
        case theme.ColorNameShadow:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x40}</span>
        default:<span class="cov0" title="0">
                return color.NRGBA{R: 0x00, G: 0x00, B: 0x00, A: 0x10}</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package gui

import (
        "encoding/pem"
        "fmt"
        "regexp"
        "strings"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/storage"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/card"
        "github.com/ubavic/bas-celik/v2/internal/gui/reader"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func cryptoList() <span class="cov0" title="0">{
        if state.cryptoUiContainer.Visible() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">state.mu.Lock()

        createCryptoUI()

        if state.cryptoUi != nil </span><span class="cov0" title="0">{
                state.startPage.Hide()
                state.documentUiMainContainer.Hide()
                state.cryptoUiContainer.Add(state.cryptoUi)
                state.cryptoUiContainer.Show()
        }</span>

        <span class="cov0" title="0">state.mu.Unlock()</span>
}

func createCryptoUI() <span class="cov0" title="0">{
        state.certs = nil
        state.selectedCert = -1

        gemaltoCard, ok := state.cardDocument.(*card.Gemalto)
        if !ok </span><span class="cov0" title="0">{
                state.cryptoUi = nil
                setStatus("crypto.wrongCard", fmt.Errorf("card could not be casted to Gemalto card"))
                return
        }</span>

        <span class="cov0" title="0">reader.CancelReaderPoler()

        err := gemaltoCard.LoadCertificates()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
        }</span>

        <span class="cov0" title="0">state.certs = gemaltoCard.GetCertificates()
        state.selectedCert = 0

        logger.Info(fmt.Sprintf("loaded %d certificates", len(state.certs)))

        reader.RestartReaderPoler()

        canvasObjects := []fyne.CanvasObject{}

        if len(state.certs) == 0 </span><span class="cov0" title="0">{
                spacer := `                                                     `
                spacer += spacer + spacer
                noCertFound := widget.NewLabel(spacer + "\n\n\n\n\n" + t("crypto.noCertFound") + "\n\n\n\n\n\n\n")
                noCertFound.Alignment = fyne.TextAlignCenter
                labelContainer := container.New(layout.NewCenterLayout(), noCertFound)

                canvasObjects = append(canvasObjects, labelContainer)
        }</span> else<span class="cov0" title="0"> {
                certInfoObjects, selectCert := renderCertInformationObjects()

                if len(state.certs) &gt; 1 </span><span class="cov0" title="0">{
                        certSelector := renderCertSelector(selectCert)
                        canvasObjects = append(canvasObjects, certSelector)
                }</span>

                <span class="cov0" title="0">selectCert(0)
                paintSelectedCert(0)

                canvasObjects = append(canvasObjects, certInfoObjects...)</span>
        }

        <span class="cov0" title="0">buttons := []fyne.CanvasObject{}
        exitButton := widget.NewButtonWithIcon(t("crypto.return"), theme.NavigateBackIcon(), closeCryptoUi)
        changePinButton := widget.NewButton(t("crypto.changePin"), pinChange())
        buttons = append(buttons, exitButton, layout.NewSpacer(), changePinButton)

        if len(state.certs) &gt; 0 </span><span class="cov0" title="0">{
                saveCertButton := widget.NewButton(t("crypto.saveCert"), saveCert)
                buttons = append(buttons, saveCertButton)
        }</span>

        <span class="cov0" title="0">buttonBar := container.New(layout.NewHBoxLayout(), buttons...)

        canvasObjects = append(canvasObjects, layout.NewSpacer(), buttonBar)

        state.cryptoUi = container.New(layout.NewVBoxLayout(), canvasObjects...)</span>
}

func renderCertSelector(selectCert func(int)) fyne.CanvasObject <span class="cov0" title="0">{
        state.certsSelectorButtons = make([]*widget.Button, 0, len(state.certs))
        objects := make([]fyne.CanvasObject, 0, len(state.certs))

        for i, cert := range state.certs </span><span class="cov0" title="0">{
                button := widget.NewButton("CERT #"+cert.SerialNumber.String()[0:6], func() </span><span class="cov0" title="0">{
                        selectCert(i)
                        paintSelectedCert(i)
                }</span>)

                <span class="cov0" title="0">objects = append(objects, button)
                state.certsSelectorButtons = append(state.certsSelectorButtons, button)</span>
        }

        <span class="cov0" title="0">renderCertSelector := container.New(layout.NewHBoxLayout(), objects...)

        return renderCertSelector</span>
}

func paintSelectedCert(i int) <span class="cov0" title="0">{
        for j, button := range state.certsSelectorButtons </span><span class="cov0" title="0">{
                if i == j </span><span class="cov0" title="0">{
                        button.Importance = widget.HighImportance
                }</span> else<span class="cov0" title="0"> {
                        button.Importance = widget.LowImportance
                }</span>

                <span class="cov0" title="0">button.Refresh()</span>
        }
}

func renderCertInformationObjects() ([]fyne.CanvasObject, func(int)) <span class="cov0" title="0">{
        canvasObjects := []fyne.CanvasObject{}

        fieldSerNo := widgets.NewField(t("crypto.serialNumber"), "", 280)
        fieldSig := widgets.NewField(t("crypto.signatureAlgorithm"), "", 290)
        generalRow1 := container.New(layout.NewHBoxLayout(), fieldSerNo, fieldSig)
        fieldNotBefore := widgets.NewField(t("crypto.notBefore"), "", 280)
        fieldNotAfter := widgets.NewField(t("crypto.notAfter"), "", 290)
        generalRow2 := container.New(layout.NewHBoxLayout(), fieldNotBefore, fieldNotAfter)
        generalGroup := widgets.NewGroup(t("crypto.general"), generalRow1, generalRow2)

        issuerSnField := widgets.NewField("SN", "", 280)
        issuerCnField := widgets.NewField("CN", "", 290)
        issuerRow1 := container.New(layout.NewHBoxLayout(), issuerSnField, issuerCnField)
        issuerOUField := widgets.NewField("OU", "", 280)
        issuerOField := widgets.NewField("O", "", 290)
        issuerRow2 := container.New(layout.NewHBoxLayout(), issuerOUField, issuerOField)
        issuerCField := widgets.NewField("C", "", 280)
        issuerLField := widgets.NewField("L", "", 290)
        issuerRow3 := container.New(layout.NewHBoxLayout(), issuerCField, issuerLField)
        issuerGroup := widgets.NewGroup(t("crypto.issuer"), issuerRow1, issuerRow2, issuerRow3)

        subjectSnField := widgets.NewField("SN", "", 280)
        subjectCnField := widgets.NewField("CN", "", 290)
        subjectRow1 := container.New(layout.NewHBoxLayout(), subjectSnField, subjectCnField)
        subjectOUField := widgets.NewField("OU", "", 280)
        subjectOField := widgets.NewField("O", "", 290)
        subjectRow2 := container.New(layout.NewHBoxLayout(), subjectOUField, subjectOField)
        subjectCField := widgets.NewField("C", "", 280)
        subjectLField := widgets.NewField("L", "", 290)
        subjectRow3 := container.New(layout.NewHBoxLayout(), subjectCField, subjectLField)
        subjectGroup := widgets.NewGroup(t("crypto.subject"), subjectRow1, subjectRow2, subjectRow3)

        selectCert := func(index int) </span><span class="cov0" title="0">{
                if state.selectedCert &gt;= len(state.certs) || state.selectedCert &lt; 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">state.selectedCert = index
                cert := state.certs[index]

                fieldSerNo.SetValue(cert.SerialNumber.String())
                fieldSig.SetValue(cert.SignatureAlgorithm.String())
                fieldNotAfter.SetValue(cert.NotAfter.Format("02.01.2006"))
                fieldNotBefore.SetValue(cert.NotBefore.Format("02.01.2006"))

                issuerSnField.SetValue(cert.Issuer.SerialNumber)
                issuerCnField.SetValue(cert.Issuer.CommonName)
                issuerOUField.SetValue(strings.Join(cert.Issuer.OrganizationalUnit, ","))
                issuerOField.SetValue(strings.Join(cert.Issuer.Organization, ","))
                issuerLField.SetValue(strings.Join(cert.Issuer.Locality, ","))
                issuerCField.SetValue(strings.Join(cert.Issuer.Country, ","))

                subjectSnField.SetValue(cert.Subject.SerialNumber)
                subjectCnField.SetValue(cert.Subject.CommonName)
                subjectOUField.SetValue(strings.Join(cert.Subject.OrganizationalUnit, ","))
                subjectOField.SetValue(strings.Join(cert.Subject.Organization, ","))
                subjectLField.SetValue(strings.Join(cert.Subject.Locality, ","))
                subjectCField.SetValue(strings.Join(cert.Subject.Country, ","))

                if len(cert.Subject.OrganizationalUnit)+len(cert.Subject.Organization) == 0 </span><span class="cov0" title="0">{
                        subjectOField.Hide()
                        subjectOUField.Hide()
                }</span> else<span class="cov0" title="0"> {
                        subjectOField.Show()
                        subjectOField.Show()
                }</span>
        }

        <span class="cov0" title="0">canvasObjects = append(canvasObjects, generalGroup, issuerGroup, subjectGroup)

        return canvasObjects, selectCert</span>
}

func saveCert() <span class="cov0" title="0">{
        cert := state.certs[state.selectedCert]

        dialog := dialog.NewFileSave(func(w fyne.URIWriteCloser, err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        setStatus("error.writingCert", fmt.Errorf("writing certificate: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">if w == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if state.selectedCert &gt;= len(state.certs) || state.selectedCert &lt; 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">pemBlock := pem.Block{
                        Type:  "CERTIFICATE",
                        Bytes: cert.Raw,
                }

                err = pem.Encode(w, &amp;pemBlock)
                if err != nil </span><span class="cov0" title="0">{
                        setStatus("error.writingCert", fmt.Errorf("encoding certificate: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">err = w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        setStatus("error.writingCert", fmt.Errorf("writing certificate: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">setStatus("ui.certSaved", nil)</span>
        }, state.window)

        <span class="cov0" title="0">dialog.SetFilter(storage.NewExtensionFileFilter([]string{".pem", ".crt", ".cer"}))

        lastUsedDirectoryURI := getLastUsedDirectory()
        if lastUsedDirectoryURI != nil </span><span class="cov0" title="0">{
                dialog.SetLocation(lastUsedDirectoryURI)
        }</span>

        <span class="cov0" title="0">dialog.SetFileName(sanitizeFilename(cert.Subject.CommonName) + ".pem")

        dialog.Show()</span>
}

func closeCryptoUi() <span class="cov0" title="0">{
        state.mu.Lock()
        state.cryptoUiContainer.Hide()
        state.documentUiMainContainer.Show()
        state.cryptoUiContainer.RemoveAll()
        state.mu.Unlock()
}</span>

func sanitizeFilename(input string) string <span class="cov0" title="0">{
        re := regexp.MustCompile(`[^a-zA-Z0-9._---]+`)
        filename := re.ReplaceAllString(input, "_")

        if filename == "" </span><span class="cov0" title="0">{
                filename = "cert"
        }</span>

        <span class="cov0" title="0">return filename</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package gui

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/internal/gui/translation"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
        "github.com/ubavic/bas-celik/v2/localization"
)

func pageID(doc *document.IdDocument) *fyne.Container <span class="cov0" title="0">{
        var personalInformationGroupObjects, docGroupObjects []fyne.CanvasObject

        widthThird := (350 - 2*theme.Padding()) / 3

        nameF := widgets.NewField(t("id.name"), doc.GetFullName(), 350)
        birthDateF := widgets.NewField(t("id.birthDate"), doc.DateOfBirth, widthThird)
        sexF := widgets.NewField(t("id.sex"), doc.Sex, widthThird)
        personalNumberF := widgets.NewField(t("id.personalNumber"), doc.PersonalNumber, widthThird)
        birthRow := container.New(layout.NewHBoxLayout(), sexF, birthDateF, personalNumberF)
        birthPlaceF := widgets.NewField(t("id.birthPlace"), doc.GetFullPlaceOfBirth(), 350)
        addressF := widgets.NewField(t("id.address"), doc.GetFullAddress(false), 350)
        addressDateF := widgets.NewField(t("id.addressDate"), doc.AddressDate, 10)

        personalInformationGroupObjects = []fyne.CanvasObject{nameF, birthRow, birthPlaceF, addressF, addressDateF}

        nationalityLabel := t("id.nationalityFull")
        foreignerStatusLabel := t("id.foreignerStatus")
        purposeOfStayLabel := t("id.purposeOfStay")
        eNoteLabel := t("id.eNote")

        if doc.DocumentType == document.ID_TYPE_IDENTITY_FOREIGNER </span><span class="cov0" title="0">{
                personalInformationGroupObjects = append(personalInformationGroupObjects,
                        widgets.NewField(nationalityLabel, doc.NationalityFull, 200),
                        widgets.NewField(foreignerStatusLabel, doc.StatusOfForeigner, 200))
        }</span> else<span class="cov0" title="0"> if doc.DocumentType == document.ID_TYPE_RESIDENCE_PERMIT </span><span class="cov0" title="0">{
                personalInformationGroupObjects = append(personalInformationGroupObjects,
                        widgets.NewField(nationalityLabel, doc.NationalityFull, 200),
                        widgets.NewField(purposeOfStayLabel, doc.PurposeOfStay, 200),
                        widgets.NewField(eNoteLabel, doc.ENote, 200))
        }</span>

        <span class="cov0" title="0">personInformationGroup := widgets.NewGroup(t("id.citizenInformation"), personalInformationGroupObjects...)

        if doc.DocumentType == document.ID_TYPE_RESIDENCE_PERMIT </span><span class="cov0" title="0">{
                docGroupObjects = append(docGroupObjects, widgets.NewField(t("id.documentName"), doc.DocumentName, 100))
        }</span>

        <span class="cov0" title="0">docGroupObjects = append(docGroupObjects, widgets.NewField(t("id.issuingAuthority"), doc.IssuingAuthority, 350))
        documentNumberF := widgets.NewField(t("id.docRegNo"), doc.DocRegNo, widthThird)
        issueDateF := widgets.NewField(t("id.issuingDate"), doc.IssuingDate, widthThird)
        expiryDateF := widgets.NewField(t("id.expiryDate"), doc.ExpiryDate, widthThird)
        docRow := container.New(layout.NewHBoxLayout(), documentNumberF, issueDateF, expiryDateF)
        docGroupObjects = append(docGroupObjects, docRow)

        docGroup := widgets.NewGroup(t("id.documentInformation"), docGroupObjects...)

        colRight := container.New(layout.NewVBoxLayout(), personInformationGroup, docGroup)

        imgWidget := canvas.NewImageFromImage(doc.Portrait)
        imgWidget.SetMinSize(fyne.Size{Width: 200, Height: 250})
        imgWidget.FillMode = canvas.ImageFillContain

        cryptoButton := widget.NewButton(t("ui.crypto"), cryptoList)
        cryptoButton.Alignment = widget.ButtonAlignCenter
        cryptoButton.Importance = widget.LowImportance

        colLeft := container.New(layout.NewVBoxLayout(), imgWidget, cryptoButton)

        return container.New(layout.NewHBoxLayout(), colLeft, &amp;widget.Separator{}, colRight)</span>
}

func pageMedical(doc *document.MedicalDocument) *fyne.Container <span class="cov0" title="0">{
        nameF := widgets.NewField(t("medical.fullName"), doc.GetFullName(), 350)
        genderF := widgets.NewField(t("medical.gender"), doc.Gender, 170)
        birthDateF := widgets.NewField(t("medical.dateOfBirth"), doc.DateOfBirth, 170)
        birthRow := container.New(layout.NewHBoxLayout(), genderF, birthDateF)

        personalNumberF := widgets.NewField(t("medical.personalNumber"), doc.PersonalNumber, 170)
        insurantNumberF := widgets.NewField(t("medical.insuranceNumber"), doc.InsurantNumber, 170)
        idsRow := container.New(layout.NewHBoxLayout(), personalNumberF, insurantNumberF)

        countryF := widgets.NewField(t("medical.country"), doc.Country, 170)
        municipalityF := widgets.NewField(t("medical.municipality"), doc.Municipality, 170)
        address1Row := container.New(layout.NewHBoxLayout(), countryF, municipalityF)

        placeF := widgets.NewField(t("medical.place"), doc.Place, 170)
        street := widgets.NewField(t("medical.street"), doc.Street, 170)
        address2Row := container.New(layout.NewHBoxLayout(), placeF, street)

        halfWidth := (170 - 3*theme.Padding()) / 2

        addressNumber := widgets.NewField(t("medical.number"), doc.Number, halfWidth)
        addressEntrance := widgets.NewField(t("medical.entrance"), doc.Apartment, halfWidth)
        addressApartmentNumber := widgets.NewField(t("medical.apartment"), doc.Apartment, 170)
        address3Row := container.New(layout.NewHBoxLayout(), addressNumber, addressEntrance, addressApartmentNumber)

        generalGroup := widgets.NewGroup(t("medical.generalInformation"), nameF, birthRow, idsRow, address1Row, address2Row, address3Row)

        insuranceBasisF := widgets.NewField(t("medical.insuranceBasis"), doc.InsuranceBasisRZZO, 170)
        insuranceStartDateF := widgets.NewField(t("medical.insuranceStartDate"), doc.InsuranceStartDate, 170)
        insuranceRow := container.New(layout.NewHBoxLayout(), insuranceBasisF, insuranceStartDateF)

        insuranceDescriptionF := widgets.NewField(t("medical.insuranceDescription"), doc.InsuranceDescription, 350)
        insuranceGroup := widgets.NewGroup(t("medical.insuranceInformation"), insuranceRow, insuranceDescriptionF)

        colLeft := container.New(layout.NewVBoxLayout(), generalGroup, insuranceGroup)

        carrierNameF := widgets.NewField(t("medical.carrier"), doc.CarrierGivenNameLatin+" "+doc.CarrierFamilyNameLatin, 350)
        carrierInsurantNumberF := widgets.NewField(t("medical.insuranceNumber"), doc.CarrierInsurantNumber, 170)
        carrierIdNumberF := widgets.NewField(t("medical.personalNumber"), doc.CarrierIdNumber, 170)
        carrierRow1 := container.New(layout.NewHBoxLayout(), carrierInsurantNumberF, carrierIdNumberF)

        carrierFamilyMemberF := widgets.NewField(t("medical.familyMember"), localization.FormatYesNo(doc.CarrierFamilyMember, translation.CurrentLanguage()), 170)
        carrierRelationshipF := widgets.NewField(t("medical.relationship"), doc.CarrierRelationship, 170)
        carrierRow2 := container.New(layout.NewHBoxLayout(), carrierFamilyMemberF, carrierRelationshipF)
        carrierGroup := widgets.NewGroup(t("medical.insuranceCarrierInformation"), carrierNameF, carrierRow1, carrierRow2)
        cardNumber := widgets.NewField(t("medical.cardId"), doc.CardId, 270)
        dateOfIssueF := widgets.NewField(t("medical.dateOfIssue"), doc.DateOfIssue, 170)
        dateOfExpiryF := widgets.NewField(t("medical.dateOfExpiry"), doc.DateOfExpiry, 170)
        cardRow1 := container.New(layout.NewHBoxLayout(), dateOfIssueF, dateOfExpiryF)

        validUntilF := widgets.NewField(t("medical.validUntil"), doc.ValidUntil, 170)
        permanentlyValidF := widgets.NewField(t("medical.permanentlyValid"), localization.FormatYesNo(doc.PermanentlyValid, translation.CurrentLanguage()), 170)
        cardRow2 := container.New(layout.NewHBoxLayout(), validUntilF, permanentlyValidF)

        cardGroup := widgets.NewGroup(t("medical.cardInformation"), cardNumber, cardRow1, cardRow2)

        taxpayerNameF := widgets.NewField(t("medical.taxpayerName"), doc.TaxpayerName, 350)
        taxpayerActivityCodeF := widgets.NewField(t("medical.taxpayerActivityCode"), doc.TaxpayerActivityCode, 170)
        taxpayerPlaceF := widgets.NewField(t("medical.taxpayerResidence"), doc.TaxpayerResidence, 170)
        taxpayerRow1 := container.New(layout.NewHBoxLayout(), taxpayerActivityCodeF, taxpayerPlaceF)
        taxpayerNumberF := widgets.NewField(t("medical.taxpayerNumber"), doc.TaxpayerNumber, 170)
        taxpayerIdNumberF := widgets.NewField(t("medical.taxpayerIdNumber"), doc.TaxpayerIdNumber, 170)
        taxpayerRow2 := container.New(layout.NewHBoxLayout(), taxpayerNumberF, taxpayerIdNumberF)

        taxpayerGroup := widgets.NewGroup(t("medical.taxpayerInformation"), taxpayerNameF, taxpayerRow1, taxpayerRow2)

        colRight := container.New(layout.NewVBoxLayout(), carrierGroup, cardGroup, taxpayerGroup)

        note := widget.NewLabel(t("medical.dateNote"))
        note.Wrapping = fyne.TextWrapWord

        return container.New(layout.NewVBoxLayout(), container.New(layout.NewHBoxLayout(), colLeft, colRight), note)
}</span>

func pageVehicle(doc *document.VehicleDocument) *fyne.Container <span class="cov0" title="0">{
        issuingStateF := widgets.NewField(t("vehicle.stateIssuing"), doc.StateIssuing, 220)
        issuedByF := widgets.NewField(t("vehicle.authorityIssuing"), doc.AuthorityIssuing, 220)
        issueRow := container.New(layout.NewHBoxLayout(), issuingStateF, issuedByF)
        issuingDateF := widgets.NewField(t("vehicle.issuingDate"), doc.IssuingDate, 220)
        expiryDateF := widgets.NewField(t("vehicle.expiryDate"), doc.ExpiryDate, 220)
        dateRow := container.New(layout.NewHBoxLayout(), issuingDateF, expiryDateF)
        competentAuthorityF := widgets.NewField(t("vehicle.competentAuthority"), doc.CompetentAuthority, 350)
        docIdF := widgets.NewField(t("vehicle.unambiguousNumber"), doc.UnambiguousNumber, 220)
        serialNumberF := widgets.NewField(t("vehicle.serialNumber"), doc.SerialNumber, 220)
        idRow := container.New(layout.NewHBoxLayout(), docIdF, serialNumberF)
        documentGroup := widgets.NewGroup(t("vehicle.documentInformation"), issueRow, dateRow, competentAuthorityF, idRow)

        ownerNoLbl := ""
        if len(doc.OwnersPersonalNo) &gt; 9 </span><span class="cov0" title="0">{
                ownerNoLbl = t("vehicle.ownersPersonalNo")
        }</span> else<span class="cov0" title="0"> {
                ownerNoLbl = t("vehicle.ownersCompanyNo")
        }</span>

        <span class="cov0" title="0">ownerF := widgets.NewField(t("vehicle.ownersSurnameOrBusinessName"), doc.OwnersSurnameOrBusinessName, 220)
        ownerNameF := widgets.NewField(t("vehicle.ownerName"), doc.OwnerName, 220)
        ownerRow := container.New(layout.NewHBoxLayout(), ownerF, ownerNameF)
        ownerNumberF := widgets.NewField(ownerNoLbl, doc.OwnersPersonalNo, 350)
        ownerAddressF := widgets.NewField(t("vehicle.ownerAddress"), doc.OwnerAddress, 350)

        userWidgets := []fyne.CanvasObject{ownerRow, ownerNumberF, ownerAddressF}
        if doc.UsersSurnameOrBusinessName != "" || doc.UsersName != "" || doc.UsersAddress != "" </span><span class="cov0" title="0">{
                userNoLbl := ""
                if len(doc.OwnersPersonalNo) &gt; 9 </span><span class="cov0" title="0">{
                        userNoLbl = t("vehicle.usersPersonalNo")
                }</span> else<span class="cov0" title="0"> {
                        userNoLbl = t("vehicle.usersCompanyNo")
                }</span>

                <span class="cov0" title="0">userF := widgets.NewField(t("vehicle.usersSurnameOrBusinessName"), doc.UsersSurnameOrBusinessName, 220)
                userNameF := widgets.NewField(t("vehicle.usersName"), doc.UsersName, 220)
                userRow := container.New(layout.NewHBoxLayout(), userF, userNameF)
                userNumberF := widgets.NewField(userNoLbl, doc.UsersPersonalNo, 350)
                userAddressF := widgets.NewField(t("vehicle.usersAddress"), doc.UsersAddress, 350)
                userWidgets = append(userWidgets, userRow, userNumberF, userAddressF)</span>
        }

        <span class="cov0" title="0">ownerGroup := widgets.NewGroup(t("vehicle.ownerInformation"), userWidgets...)

        colLeft := container.New(layout.NewVBoxLayout(), documentGroup, ownerGroup)

        registrationNumberF := widgets.NewField(t("vehicle.registrationNumberOfVehicle"), doc.RegistrationNumberOfVehicle, 220)
        dateOfFirstRegistrationF := widgets.NewField(t("vehicle.dateOfFirstRegistration"), doc.DateOfFirstRegistration, 220)
        vehicleRow0 := container.New(layout.NewHBoxLayout(), registrationNumberF, dateOfFirstRegistrationF)

        brandF := widgets.NewField(t("vehicle.vehicleMake"), doc.VehicleMake, 220)
        modelF := widgets.NewField(t("vehicle.commercialDescription"), doc.CommercialDescription, 220)
        vehicleRow1 := container.New(layout.NewHBoxLayout(), brandF, modelF)

        colorF := widgets.NewField(t("vehicle.colourOfVehicle"), doc.ColourOfVehicle, 220)
        yearOfProductionF := widgets.NewField(t("vehicle.yearOfProduction"), doc.YearOfProduction, 220)
        vehicleRow2 := container.New(layout.NewHBoxLayout(), colorF, yearOfProductionF)

        massF := widgets.NewField(t("vehicle.vehicleMass"), doc.VehicleMass, 220)
        maximalAllowedMassF := widgets.NewField(t("vehicle.maximumPermissibleLadenMass"), doc.MaximumPermissibleLadenMass, 220)
        vehicleRow3 := container.New(layout.NewHBoxLayout(), massF, maximalAllowedMassF)

        enginePowerF := widgets.NewField(t("vehicle.maximumNetPower"), doc.MaximumNetPower, 220)
        powerMassRatioF := widgets.NewField(t("vehicle.powerWeightRatio"), doc.PowerWeightRatio, 220)
        vehicleRow4 := container.New(layout.NewHBoxLayout(), enginePowerF, powerMassRatioF)

        engineNumberF := widgets.NewField(t("vehicle.engineIdNumber"), doc.EngineIdNumber, 220)
        engineCapacityF := widgets.NewField(t("vehicle.engineCapacity"), doc.EngineCapacity, 220)
        vehicleRow5 := container.New(layout.NewHBoxLayout(), engineNumberF, engineCapacityF)

        seatsF := widgets.NewField(t("vehicle.numberOfSeats"), doc.NumberOfSeats, 220)
        standingF := widgets.NewField(t("vehicle.numberOfStandingPlaces"), doc.NumberOfStandingPlaces, 220)
        vehicleRow6 := container.New(layout.NewHBoxLayout(), seatsF, standingF)

        insuranceHolderGroup := widgets.NewGroup(t("vehicle.vehicleInformation"),
                vehicleRow0, vehicleRow1, vehicleRow2, vehicleRow3,
                vehicleRow4, vehicleRow5, vehicleRow6,
        )

        colRight := container.New(layout.NewVBoxLayout(), insuranceHolderGroup)

        return container.New(layout.NewHBoxLayout(), colLeft, colRight)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package icon

import (
        "embed"
        "fmt"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/theme"
)

var CertificateThemedResource *theme.ThemedResource
var PinThemedResource *theme.ThemedResource

func LoadIcons(embedFS embed.FS) error <span class="cov0" title="0">{
        certificateSvg, err := embedFS.ReadFile("embed/icons/certificate.svg")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading certificate icon: %w", err)
        }</span>

        <span class="cov0" title="0">CertificateThemedResource = theme.NewThemedResource(&amp;fyne.StaticResource{
                StaticName:    "certificate.svg",
                StaticContent: certificateSvg,
        })

        pinSvg, err := embedFS.ReadFile("embed/icons/pin.svg")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading pin icon: %w", err)
        }</span>

        <span class="cov0" title="0">PinThemedResource = theme.NewThemedResource(&amp;fyne.StaticResource{
                StaticName:    "pin.svg",
                StaticContent: pinSvg,
        })

        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package gui

import (
        "errors"

        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/card"
        "github.com/ubavic/bas-celik/v2/internal/gui/reader"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func pinChange() func() <span class="cov0" title="0">{
        return func() </span><span class="cov0" title="0">{
                dialog.ShowConfirm(t("pinChange.title"), t("pinChange.note"), func(changePinContinue bool) </span><span class="cov0" title="0">{
                        if changePinContinue </span><span class="cov0" title="0">{
                                pinForm()
                        }</span>
                }, state.window)
        }
}

func pinForm() <span class="cov0" title="0">{
        var pinDialog *dialog.CustomDialog

        oldPinEntry := widget.NewPasswordEntry()
        newPinEntry := widget.NewPasswordEntry()
        confirmNewPinEntry := widget.NewPasswordEntry()

        spacer := widgets.NewSpacer()
        spacer.SetMinWidth(200)

        formItems := []*widget.FormItem{
                {Text: t("pinChange.oldPin"), Widget: oldPinEntry},
                {Text: t("pinChange.newPin"), Widget: newPinEntry},
                {Text: t("pinChange.confirmNewPin"), Widget: confirmNewPinEntry},
                {Text: "", Widget: spacer},
        }

        form := &amp;widget.Form{
                Items:      formItems,
                SubmitText: t("pinChange.change"),
                OnSubmit: func() </span><span class="cov0" title="0">{
                        gemaltoCard, ok := state.cardDocument.(*card.Gemalto)
                        if !ok </span><span class="cov0" title="0">{
                                pinDialog.Hide()
                                return
                        }</span>

                        <span class="cov0" title="0">if newPinEntry.Text != confirmNewPinEntry.Text </span><span class="cov0" title="0">{
                                err := errors.New(t("pinChange.pinsNotEqual"))
                                dialog.ShowError(err, state.window)
                                return
                        }</span>

                        <span class="cov0" title="0">if !card.ValidatePin(oldPinEntry.Text) </span><span class="cov0" title="0">{
                                err := errors.New(t("pinChange.oldPinFormatError") + " " + t("pinChange.pinFormatExplanation"))
                                dialog.ShowError(err, state.window)
                                return
                        }</span>

                        <span class="cov0" title="0">if !card.ValidatePin(newPinEntry.Text) </span><span class="cov0" title="0">{
                                err := errors.New(t("pinChange.newPinFormatError") + " " + t("pinChange.pinFormatExplanation"))
                                dialog.ShowError(err, state.window)
                                return
                        }</span>

                        <span class="cov0" title="0">if !card.ValidatePin(confirmNewPinEntry.Text) </span><span class="cov0" title="0">{
                                err := errors.New(t("pinChange.confirmNewPinFormatError") + " " + t("pinChange.pinFormatExplanation"))
                                dialog.ShowError(err, state.window)
                                return
                        }</span>

                        <span class="cov0" title="0">if state.cardDocument == nil </span><span class="cov0" title="0">{
                                err := errors.New(t("pinChange.errorNoCard"))
                                dialog.ShowError(err, state.window)
                                return
                        }</span>

                        <span class="cov0" title="0">reader.CancelReaderPoler()
                        triesLeft, err := gemaltoCard.ChangePin(newPinEntry.Text, oldPinEntry.Text)
                        if err != nil </span><span class="cov0" title="0">{
                                pinDialog.Hide()
                                message := t("pinChange.error")
                                if triesLeft &gt; -1 </span><span class="cov0" title="0">{
                                        message += "\n" + t("pinChange.triesLeft", triesLeft)
                                }</span>
                                <span class="cov0" title="0">dialog.ShowInformation(t("pinChange.title"), message, state.window)
                                logger.Error(err)
                                return</span>
                        } else<span class="cov0" title="0"> {
                                pinDialog.Hide()
                                dialog.ShowInformation(t("pinChange.title"), t("pinChange.success"), state.window)
                                logger.Info("pin changed")
                        }</span>
                        <span class="cov0" title="0">reader.RestartReaderPoler()</span>
                },
                CancelText: t("pinChange.cancel"),
                OnCancel: func() <span class="cov0" title="0">{
                        pinDialog.Hide()
                }</span>,
        }

        <span class="cov0" title="0">pinDialog = dialog.NewCustomWithoutButtons(t("pinChange.title"), form, state.window)
        pinDialog.Show()</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package gui

import (
        "fmt"

        "github.com/ebfe/scard"
        "github.com/ubavic/bas-celik/v2/card"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func connectToCard(selectedReader string, ctx *scard.Context) <span class="cov0" title="0">{
        state.mu.Lock()
        state.cardDocument = nil
        state.cryptoUi = nil
        state.certs = nil
        state.selectedCert = -1
        state.mu.Unlock()

        state.cryptoUiContainer.Hide()
        state.cryptoUiContainer.RemoveAll()

        readers, _ := ctx.ListReaders()
        if selectedReader == "" || len(readers) == 0 </span><span class="cov0" title="0">{
                setStartPage("error.noReader", "error.noReaderExplanation", nil)
                return
        }</span>

        <span class="cov0" title="0">setStartPage("poller.connectingReader", "", nil)

        sCard, err := ctx.Connect(selectedReader, scard.ShareShared, scard.ProtocolAny)
        if err == nil </span><span class="cov0" title="0">{
                err = sCard.BeginTransaction()
                if err == nil </span><span class="cov0" title="0">{
                        tryToProcessCard(sCard)
                        sCard.EndTransaction(scard.LeaveCard)
                        return
                }</span>
        }

        <span class="cov0" title="0">setStartPage(
                "error.readingCard",
                "error.isCardPresent",
                fmt.Errorf("connecting reader %s: %w", selectedReader, err))</span>
}

func tryToProcessCard(sCard *scard.Card) bool <span class="cov0" title="0">{
        loaded := false

        setStartPage("poller.readingFromCard", "", nil)

        cardDoc, err := card.DetectCardDocument(sCard)
        if cardDoc != nil </span><span class="cov0" title="0">{
                logger.Info("ATR read: " + cardDoc.Atr().String())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                message := ""
                if err == card.ErrUnknownCard </span><span class="cov0" title="0">{
                        message = "error.unknownCard"
                }</span>
                <span class="cov0" title="0">setStartPage(
                        "error.readingCard",
                        message,
                        fmt.Errorf("reading from card: %w", err))</span>
        } else<span class="cov0" title="0"> {
                state.mu.Lock()
                state.cardDocument = cardDoc
                state.mu.Unlock()

                doc, err := initCardAndReadDoc(cardDoc)
                if err != nil </span><span class="cov0" title="0">{
                        setStartPage(
                                "error.readingCard",
                                "",
                                fmt.Errorf("reading from card: %w", err))
                }</span> else<span class="cov0" title="0"> {
                        setStatus("poller.documentRead", nil)
                        setUI(doc)
                        loaded = true
                }</span>

                <span class="cov0" title="0">switch cardDoc.(type) </span>{
                case *card.Gemalto:<span class="cov0" title="0">
                        state.mu.Lock()
                        state.mu.Unlock()</span>
                }
        }

        <span class="cov0" title="0">return loaded</span>
}

func initCardAndReadDoc(cardDoc card.CardDocument) (document.Document, error) <span class="cov0" title="0">{
        err := cardDoc.InitCard()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = cardDoc.ReadCard()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">doc, err := cardDoc.GetDocument()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return doc, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package gui

import (
        "runtime"

        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
        "github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11"
)

const themePreferenceKey = "color-theme"
const languagePreferenceKey = "language"
const smartboxModeKey = "smartbox-mode"
const lastUsedDirectoryKey = "last-used-directory"

const mupPkcsPathKey = "mup-pkcs-path"
const pksPkcsPathKey = "pks-pkcs-path"
const postaPkcsPathKey = "posta-pkcs-path"
const halcomPkcsPathKey = "halcom-pkcs-path"
const esmartPkcsPathKey = "esmart-pkcs-path"

func showSetupBox() func() <span class="cov0" title="0">{
        preferences := state.app.Preferences()

        return func() </span><span class="cov0" title="0">{
                colorTheme := preferences.IntWithFallback(themePreferenceKey, 0)
                themeSelect := widget.NewSelect(
                        []string{t("preference.theme.osDetermines"), t("preference.theme.alwaysLight"), t("preference.theme.alwaysDark")},
                        func(s string) </span>{<span class="cov0" title="0">}</span>)
                <span class="cov0" title="0">themeSelect.SetSelectedIndex(colorTheme)

                language := preferences.IntWithFallback(languagePreferenceKey, 0)
                languageSelect := widget.NewSelect(
                        []string{"Srpski", "", "English"},
                        func(s string) </span>{<span class="cov0" title="0">}</span>,
                )
                <span class="cov0" title="0">languageSelect.SetSelectedIndex(language)

                mupPkcsEntry := widget.NewEntry()
                mupPkcsEntry.SetText(preferences.String(mupPkcsPathKey))
                pksPkcsEntry := widget.NewEntry()
                pksPkcsEntry.SetText(preferences.String(pksPkcsPathKey))
                postaPkcsEntry := widget.NewEntry()
                postaPkcsEntry.SetText(preferences.String(postaPkcsPathKey))
                halcomPkcsEntry := widget.NewEntry()
                halcomPkcsEntry.SetText(preferences.String(halcomPkcsPathKey))
                esmartPkcsEntry := widget.NewEntry()
                esmartPkcsEntry.SetText(preferences.String(esmartPkcsPathKey))

                var afterChangeSmartboxMode func()

                changeSmartboxMode := func(mode bool) </span><span class="cov0" title="0">{
                        if mode </span><span class="cov0" title="0">{
                                mupPkcsEntry.Enable()
                                pksPkcsEntry.Enable()
                                postaPkcsEntry.Enable()
                                halcomPkcsEntry.Enable()
                                esmartPkcsEntry.Enable()

                                if mupPkcsEntry.Text+pksPkcsEntry.Text+postaPkcsEntry.Text+halcomPkcsEntry.Text+esmartPkcsEntry.Text == "" </span><span class="cov0" title="0">{
                                        mupPkcsEntry.SetText(pkcs11.GetDefaultPath(pkcs11.CardVendorMup, runtime.GOOS))
                                        pksPkcsEntry.SetText(pkcs11.GetDefaultPath(pkcs11.CardVendorPks, runtime.GOOS))
                                        postaPkcsEntry.SetText(pkcs11.GetDefaultPath(pkcs11.CardVendorPosta, runtime.GOOS))
                                        halcomPkcsEntry.SetText(pkcs11.GetDefaultPath(pkcs11.CardVendorHalcom, runtime.GOOS))
                                        esmartPkcsEntry.SetText(pkcs11.GetDefaultPath(pkcs11.CardVendorEsmart, runtime.GOOS))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                mupPkcsEntry.Disable()
                                pksPkcsEntry.Disable()
                                postaPkcsEntry.Disable()
                                halcomPkcsEntry.Disable()
                                esmartPkcsEntry.Disable()
                        }</span>

                        <span class="cov0" title="0">if afterChangeSmartboxMode != nil </span><span class="cov0" title="0">{
                                afterChangeSmartboxMode()
                        }</span>
                }

                <span class="cov0" title="0">smartboxMode := preferences.BoolWithFallback(smartboxModeKey, false)
                smartboxModeCheck := widget.NewCheck("", changeSmartboxMode)
                smartboxModeCheck.SetChecked(smartboxMode)

                if !smartboxMode </span><span class="cov0" title="0">{
                        changeSmartboxMode(false)
                }</span>

                <span class="cov0" title="0">formItems := []*widget.FormItem{
                        {Text: t("preference.theme"), Widget: themeSelect},
                        {Text: t("preference.language"), Widget: languageSelect},
                        {Text: t("preference.smartboxMode"), Widget: smartboxModeCheck},
                        {Text: "MUP", Widget: mupPkcsEntry},
                        {Text: "PKS", Widget: pksPkcsEntry},
                        {Text: "Pota", Widget: postaPkcsEntry},
                        {Text: "Halcom", Widget: halcomPkcsEntry},
                        {Text: "E-Smart", Widget: esmartPkcsEntry},
                        {Text: "", Widget: &amp;widgets.Spacer{}},
                }

                save := func() </span><span class="cov0" title="0">{
                        preferences.SetInt(themePreferenceKey, themeSelect.SelectedIndex())
                        preferences.SetInt(languagePreferenceKey, languageSelect.SelectedIndex())
                        preferences.SetBool(smartboxModeKey, smartboxModeCheck.Checked)
                        preferences.SetString(mupPkcsPathKey, mupPkcsEntry.Text)
                        preferences.SetString(pksPkcsPathKey, pksPkcsEntry.Text)
                        preferences.SetString(postaPkcsPathKey, postaPkcsEntry.Text)
                        preferences.SetString(halcomPkcsPathKey, halcomPkcsEntry.Text)
                        preferences.SetString(esmartPkcsPathKey, esmartPkcsEntry.Text)

                        dialog.ShowInformation(t("preference.saved"), t("preference.startAgain"), state.window)
                }</span>

                <span class="cov0" title="0">form := widget.Form{
                        Items:      formItems,
                        SubmitText: t("preference.save"),
                        CancelText: t("preference.exit"),
                        OnSubmit: func() </span><span class="cov0" title="0">{
                                save()
                                showDocumentUI()
                                setTimedStatus(t("preference.saved"))
                        }</span>,
                        OnCancel: func() <span class="cov0" title="0">{
                                showDocumentUI()
                                setTimedStatus("")
                        }</span>,
                }

                <span class="cov0" title="0">afterChangeSmartboxMode = func() </span><span class="cov0" title="0">{
                        form.Refresh()
                }</span>

                <span class="cov0" title="0">title := canvas.NewText(t("preference.title"), theme.Color(theme.ColorNameForeground))
                title.TextStyle.Bold = true
                title.TextSize = 20

                rows := container.New(layout.NewVBoxLayout(), title, &amp;form)

                state.mainContainer.RemoveAll()
                state.mainContainer.Add(rows)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//go:build linux

package reader

import (
        "github.com/ebfe/scard"
)

func (rp *ReaderPoller) waitForReaderChange(_ int) <span class="cov0" title="0">{
        state := scard.ReaderState{
                Reader:       `\\?PnP?\Notification`,
                CurrentState: scard.StateUnaware,
        }

        states := []scard.ReaderState{state}
        rp.readerListerContext.GetStatusChange(states, -1)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package reader

import (
        "fmt"
        "slices"
        "sync/atomic"

        "github.com/ebfe/scard"
        "github.com/ubavic/bas-celik/v2/card"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

var created = false
var createdPoller *ReaderPoller

type ReaderPoller struct {
        readerListerContext *scard.Context
        singleReaderContext *scard.Context
        readerLister        ReaderLister
        currentReader       string
        readers             []string
        readerPollerStarted atomic.Bool
        onCardEvent         func(string, *scard.Context)
}

type ReaderLister interface {
        SetReaders([]string, string)
        HookReaderChange(func(string))
}

func NewPoller(readerLister ReaderLister, onCardEvent func(string, *scard.Context)) (*ReaderPoller, error) <span class="cov0" title="0">{
        if created </span><span class="cov0" title="0">{
                panic("you can create only single instance of ReaderPoller")</span>
        }
        <span class="cov0" title="0">created = true

        readerListerContext, err := scard.EstablishContext()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating reader list context: %w", err)
        }</span>

        <span class="cov0" title="0">singleReaderContext, err := scard.EstablishContext()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating single reader context: %w", err)
        }</span>

        <span class="cov0" title="0">poller := ReaderPoller{
                readerListerContext: readerListerContext,
                singleReaderContext: singleReaderContext,
                readerLister:        readerLister,
                onCardEvent:         onCardEvent,
        }

        readerLister.HookReaderChange(poller.SetReader)

        createdPoller = &amp;poller

        return createdPoller, nil</span>
}

func (rp *ReaderPoller) StartPoller() <span class="cov0" title="0">{
        rp.onCardEvent("", rp.singleReaderContext)
        go rp.pollReaders()
}</span>

func (rp *ReaderPoller) pollReaders() <span class="cov0" title="0">{
        newReaders, _ := rp.readerListerContext.ListReaders()
        newReader := ""
        if len(rp.readers) &gt; 0 </span><span class="cov0" title="0">{
                newReader = rp.readers[0]
        }</span>

        <span class="cov0" title="0">rp.readerLister.SetReaders(newReaders, newReader)

        readerToSelect := ""

        for </span><span class="cov0" title="0">{
                newReaders, _ = rp.readerListerContext.ListReaders()

                readersCount := len(newReaders)

                if slices.Compare(rp.readers, newReaders) != 0 </span><span class="cov0" title="0">{
                        logger.Debug("New readers list: " + fmt.Sprintf("%v", newReaders))

                        rp.readers = newReaders

                        if slices.Contains(rp.readers, rp.currentReader) </span><span class="cov0" title="0">{
                                readerToSelect = rp.currentReader
                        }</span> else<span class="cov0" title="0"> {
                                if len(rp.readers) == 0 </span><span class="cov0" title="0">{
                                        readerToSelect = ""
                                }</span> else<span class="cov0" title="0"> {
                                        readerToSelect = rp.readers[0]
                                }</span>
                        }

                        <span class="cov0" title="0">rp.readerLister.SetReaders(rp.readers, readerToSelect)
                        rp.SetReader(readerToSelect)</span>
                }

                <span class="cov0" title="0">rp.waitForReaderChange(readersCount)
                logger.Debug("Readers changed...")</span>
        }
}

func (rp *ReaderPoller) SetReader(newReader string) <span class="cov0" title="0">{
        if rp.currentReader == newReader </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Setting reader: " + newReader)

        rp.currentReader = newReader
        CancelReaderPoler()
        rp.onCardEvent(newReader, rp.singleReaderContext)
        go rp.readerPoller(newReader)</span>
}

func (rp *ReaderPoller) readerPoller(selectedReader string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if selectedReader == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">state := scard.ReaderState{
                        Reader:       selectedReader,
                        CurrentState: scard.StateUnaware,
                }

                states := []scard.ReaderState{state}

                rp.singleReaderContext.GetStatusChange(states, 0)
                for i := range states </span><span class="cov0" title="0">{
                        states[i].CurrentState = states[i].EventState
                }</span>

                <span class="cov0" title="0">logger.Debug("Reader poller event 1: " + card.FormatState(states[0].CurrentState))

                rp.readerPollerStarted.Store(true)
                err := rp.singleReaderContext.GetStatusChange(states, -1)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">logger.Debug("Reader poller event 2: " + card.FormatState(states[0].CurrentState))

                rp.onCardEvent(selectedReader, rp.singleReaderContext)</span>
        }
}

func CancelReaderPoler() <span class="cov0" title="0">{
        logger.Debug("Canceling reader poller...")
        if createdPoller.readerPollerStarted.Load() </span><span class="cov0" title="0">{
                createdPoller.readerPollerStarted.Store(false)
                createdPoller.singleReaderContext.Cancel()
        }</span>
}

func RestartReaderPoler() <span class="cov0" title="0">{
        logger.Debug("Restarting reader poller...")
        go createdPoller.readerPoller(createdPoller.currentReader)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package gui

import (
        "fmt"
        "path/filepath"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/dialog"
        "fyne.io/fyne/v2/storage"
        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func savePdf(doc document.Document) func() <span class="cov0" title="0">{
        return func() </span><span class="cov0" title="0">{
                if doc == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">pdf, fileName, err := doc.BuildPdf()

                if err != nil </span><span class="cov0" title="0">{
                        setStatus("error.generatingPdf", fmt.Errorf("generating PDF: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">dialog := dialog.NewFileSave(func(w fyne.URIWriteCloser, err error) </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                setStatus("error.writingPdf", fmt.Errorf("writing PDF: %w", err))
                                return
                        }</span>

                        <span class="cov0" title="0">if w == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">saveLastUsedDirectory(w.URI())

                        _, err = w.Write(pdf)
                        if err != nil </span><span class="cov0" title="0">{
                                setStatus("error.writingPdf", fmt.Errorf("writing PDF: %w", err))
                                return
                        }</span>

                        <span class="cov0" title="0">err = w.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                setStatus("error.writingPdf", fmt.Errorf("writing PDF: %w", err))
                                return
                        }</span>

                        <span class="cov0" title="0">setStatus("ui.pdfSaved", nil)</span>
                }, state.window)

                <span class="cov0" title="0">dialog.SetFilter(storage.NewExtensionFileFilter([]string{".pdf"}))
                dialog.SetFileName(fileName)

                lastUsedDirectoryURI := getLastUsedDirectory()
                if lastUsedDirectoryURI != nil </span><span class="cov0" title="0">{
                        dialog.SetLocation(lastUsedDirectoryURI)
                }</span>

                <span class="cov0" title="0">dialog.Show()</span>
        }
}

func saveXlsx(doc document.Document) func() <span class="cov0" title="0">{
        return func() </span><span class="cov0" title="0">{
                if doc == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">excel, fileName, err := doc.BuildExcel()

                if err != nil </span><span class="cov0" title="0">{
                        setStatus("error.generatingXlsx", fmt.Errorf("generating Xlsx: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">dialog := dialog.NewFileSave(func(w fyne.URIWriteCloser, err error) </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                setStatus("error.writingXlsx", fmt.Errorf("writing xlsx: %w", err))
                                return
                        }</span>

                        <span class="cov0" title="0">if w == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">saveLastUsedDirectory(w.URI())

                        _, err = w.Write(excel)
                        if err != nil </span><span class="cov0" title="0">{
                                setStatus("error.writingXlsx", fmt.Errorf("writing xlsx: %w", err))
                                return
                        }</span>

                        <span class="cov0" title="0">err = w.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                setStatus("error.writingXlsx", fmt.Errorf("writing xlsx: %w", err))
                                return
                        }</span>

                        <span class="cov0" title="0">setStatus("ui.xlsxSaved", nil)</span>
                }, state.window)

                <span class="cov0" title="0">dialog.SetFilter(storage.NewExtensionFileFilter([]string{".xlsx"}))
                dialog.SetFileName(fileName)

                lastUsedDirectoryURI := getLastUsedDirectory()
                if lastUsedDirectoryURI != nil </span><span class="cov0" title="0">{
                        dialog.SetLocation(lastUsedDirectoryURI)
                }</span>

                <span class="cov0" title="0">dialog.Show()</span>
        }
}

func saveLastUsedDirectory(uri fyne.URI) <span class="cov0" title="0">{
        directoryPath := filepath.Dir(uri.Path())

        if directoryPath == "." || directoryPath == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">preferences := state.app.Preferences()

        preferences.SetString(lastUsedDirectoryKey, directoryPath)</span>
}

func getLastUsedDirectory() fyne.ListableURI <span class="cov0" title="0">{
        preferences := state.app.Preferences()
        lastUsedDirectory := preferences.String(lastUsedDirectoryKey)

        if lastUsedDirectory == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fileURI := storage.NewFileURI(lastUsedDirectory)
        listableURI, err := storage.ListerForURI(fileURI)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return nil
        }</span>

        <span class="cov0" title="0">return listableURI</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package gui

import (
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11"
        "github.com/ubavic/bas-celik/v2/internal/smartbox/server"
)

func startSmartboxUI() <span class="cov0" title="0">{
        preferences := state.app.Preferences()

        modulePaths := []server.ModulePath{}

        vendors := []pkcs11.CardVendor{
                pkcs11.CardVendorMup,
                pkcs11.CardVendorPks,
                pkcs11.CardVendorPosta,
                pkcs11.CardVendorHalcom,
                pkcs11.CardVendorEsmart,
        }

        for _, vendor := range vendors </span><span class="cov0" title="0">{
                preferenceKey := getVendorPreferenceKey(vendor)

                path := preferences.String(preferenceKey)

                if path != "" </span><span class="cov0" title="0">{
                        modulePaths = append(modulePaths, server.ModulePath{
                                Vendor: vendor,
                                Path:   path,
                        })
                }</span>
        }

        <span class="cov0" title="0">rows := container.New(layout.NewVBoxLayout(), state.toolbar, state.startPage, state.statusBar)
        state.documentUi = rows

        state.mainContainer.Add(state.documentUi)

        address, err := server.StartServer(modulePaths)

        if err != nil </span><span class="cov0" title="0">{
                setStartPage("smartbox.error", "", err)
                state.statusBar.SetStatus(err.Error(), true)
                state.statusBar.Refresh()
        }</span> else<span class="cov0" title="0"> {
                setStartPage("smartbox.running", "", nil)
                state.statusBar.SetStatus(address, false)
                state.statusBar.Refresh()
        }</span>

        <span class="cov0" title="0">resizeWindow(true)

        state.window.ShowAndRun()</span>
}

func getVendorPreferenceKey(vendor pkcs11.CardVendor) string <span class="cov0" title="0">{

        switch vendor </span>{
        case pkcs11.CardVendorHalcom:<span class="cov0" title="0">
                return halcomPkcsPathKey</span>
        case pkcs11.CardVendorPosta:<span class="cov0" title="0">
                return postaPkcsPathKey</span>
        case pkcs11.CardVendorEsmart:<span class="cov0" title="0">
                return esmartPkcsPathKey</span>
        case pkcs11.CardVendorMup:<span class="cov0" title="0">
                return mupPkcsPathKey</span>
        case pkcs11.CardVendorPks:<span class="cov0" title="0">
                return pksPkcsPathKey</span>
        default:<span class="cov0" title="0">
                panic("Invalid card vendor")</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package gui

import "github.com/ubavic/bas-celik/v2/internal/gui/translation"

func t(id string, vals ...any) string <span class="cov0" title="0">{
        return translation.Translate(id, vals...)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package translation

import (
        "embed"
        "encoding/json"
        "fmt"

        "github.com/ubavic/bas-celik/v2/localization"
)

var translations map[localization.Language]map[string]string

var currentLanguage localization.Language

func SetTranslations(embedFS embed.FS) error <span class="cov0" title="0">{
        translations = make(map[localization.Language]map[string]string)

        languages := []localization.Language{localization.SrLatin, localization.SrCyrillic, localization.En}
        for _, lang := range languages </span><span class="cov0" title="0">{
                langJson, err := embedFS.ReadFile("embed/translation/" + string(lang) + ".json")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("reading %s translation: %w", lang, err)
                }</span>

                <span class="cov0" title="0">langMap := make(map[string]string)

                err = json.Unmarshal(langJson, &amp;langMap)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s translation unmarshal: %w", lang, err)
                }</span>

                <span class="cov0" title="0">translations[lang] = langMap</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func SetLanguage(lang int) <span class="cov0" title="0">{
        if lang == 2 </span><span class="cov0" title="0">{
                currentLanguage = localization.En
        }</span> else<span class="cov0" title="0"> if lang == 1 </span><span class="cov0" title="0">{
                currentLanguage = localization.SrCyrillic
        }</span> else<span class="cov0" title="0"> {
                currentLanguage = localization.SrLatin
        }</span>
}

func CurrentLanguage() localization.Language <span class="cov0" title="0">{
        return currentLanguage
}</span>

func Translate(id string, vals ...any) string <span class="cov0" title="0">{
        translation := translations[currentLanguage][id]

        if len(vals) == 0 </span><span class="cov0" title="0">{
                return translation
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf(translation, vals...)
        }</span>
}

func EnglishTranslation(id string) string <span class="cov0" title="0">{
        return translations[localization.En][id]
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package gui

import (
        "crypto/x509"
        "sync"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/app"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/card"
        "github.com/ubavic/bas-celik/v2/internal/gui/celiktheme"
        "github.com/ubavic/bas-celik/v2/internal/gui/translation"
        "github.com/ubavic/bas-celik/v2/internal/gui/widgets"
)

type State struct {
        version                 string
        mu                      sync.Mutex
        app                     fyne.App
        window                  fyne.Window
        mainContainer           *fyne.Container
        documentUi              *fyne.Container
        cryptoUiContainer       *fyne.Container
        cryptoUi                *fyne.Container
        startPage               *widgets.StartPage
        documentUiMainContainer *fyne.Container
        toolbar                 *widgets.Toolbar
        statusBar               *widgets.StatusBar
        cardDocument            card.CardDocument
        selectedCert            int
        certs                   []x509.Certificate
        certsSelectorButtons    []*widget.Button
}

var state State

func StartGui(version string) <span class="cov0" title="0">{
        app := app.New()
        win := app.NewWindow("Ba elik")

        theme := celiktheme.NewTheme(app.Preferences().IntWithFallback(themePreferenceKey, 1))
        app.Settings().SetTheme(theme)

        translation.SetLanguage(app.Preferences().IntWithFallback(languagePreferenceKey, 1))

        statusBar := widgets.NewStatusBar()

        cryptoContainer := container.New(layout.NewVBoxLayout())
        mainPage := container.New(layout.NewVBoxLayout())

        startPage := widgets.NewStartPage()
        startPage.SetStatus("", "", false)

        mainContainer := container.New(layout.NewPaddedLayout())
        win.SetContent(mainContainer)

        state = State{
                app:                     app,
                window:                  win,
                version:                 version,
                mainContainer:           mainContainer,
                cryptoUiContainer:       cryptoContainer,
                documentUiMainContainer: mainPage,
                startPage:               startPage,
                statusBar:               statusBar,
        }

        smartboxMode := app.Preferences().BoolWithFallback(smartboxModeKey, false)

        showAboutBox := showAboutBox()
        showSettings := showSetupBox()

        toolbar := widgets.NewToolbar(showAboutBox, showSettings, !smartboxMode)
        state.toolbar = toolbar

        if smartboxMode </span><span class="cov0" title="0">{
                startSmartboxUI()
        }</span> else<span class="cov0" title="0"> {
                startCardReaderUI()
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package widgets

var clipboardHook func(string) bool

func SetClipboard(hook func(string) bool) <span class="cov0" title="0">{
        clipboardHook = hook
}</span>

func copyToClipboard(str string) bool <span class="cov0" title="0">{
        if clipboardHook == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return clipboardHook(str)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package widgets

import (
        "image/color"

        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/driver/desktop"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
)

type Field struct {
        widget.BaseWidget
        name, value  string
        minWidth     float32
        hovered      bool
        copied       bool
        valueChanged bool
}

type FieldRenderer struct {
        field      *Field
        background *canvas.Rectangle
        nameText   *canvas.Text
        valueLabel *widget.Label
}

func NewField(name, value string, minWidth float32) *Field <span class="cov0" title="0">{
        field := &amp;Field{
                name:     name,
                value:    value,
                minWidth: minWidth,
        }
        field.ExtendBaseWidget(field)
        return field
}</span>

func (f *Field) CreateRenderer() fyne.WidgetRenderer <span class="cov0" title="0">{
        nameText := canvas.NewText(f.name, theme.Color(theme.ColorNameForeground))
        nameText.TextSize = 11

        valueText := widget.NewLabel(f.value)
        valueText.Alignment = fyne.TextAlignLeading
        valueText.Wrapping = fyne.TextWrapWord
        valueText.Resize(fyne.NewSize(f.minWidth, valueText.MinSize().Height))

        background := canvas.NewRectangle(color.Transparent)
        background.CornerRadius = theme.InputRadiusSize()

        return &amp;FieldRenderer{
                field:      f,
                background: background,
                nameText:   nameText,
                valueLabel: valueText,
        }
}</span>

func (f *Field) Cursor() desktop.Cursor <span class="cov0" title="0">{
        return desktop.PointerCursor
}</span>

func (f *Field) MouseIn(*desktop.MouseEvent) <span class="cov0" title="0">{
        f.copied = false
        f.hovered = true
        f.Refresh()
}</span>

func (f *Field) MouseMoved(*desktop.MouseEvent) {<span class="cov0" title="0">
}</span>

func (f *Field) MouseOut() <span class="cov0" title="0">{
        f.hovered = false
        f.Refresh()
}</span>

func (f *Field) Tapped(*fyne.PointEvent) <span class="cov0" title="0">{
        if copyToClipboard(f.value) </span><span class="cov0" title="0">{
                f.copied = true
        }</span>
        <span class="cov0" title="0">f.Refresh()</span>
}

func (f *Field) SetValue(value string) <span class="cov0" title="0">{
        f.value = value
        f.valueChanged = true
        f.Refresh()
}</span>

func (r *FieldRenderer) Refresh() <span class="cov0" title="0">{
        if r.field.valueChanged </span><span class="cov0" title="0">{
                r.valueLabel.SetText(r.field.value)
                r.field.valueChanged = false
        }</span>

        <span class="cov0" title="0">if r.field.hovered &amp;&amp; !r.field.copied </span><span class="cov0" title="0">{
                r.background.FillColor = theme.Color(theme.ColorNameButton)
        }</span> else<span class="cov0" title="0"> {
                r.background.FillColor = color.Transparent
        }</span>

        <span class="cov0" title="0">r.valueLabel.Refresh()
        r.background.Refresh()</span>
}

func (r *FieldRenderer) Layout(s fyne.Size) <span class="cov0" title="0">{
        r.nameText.Move(fyne.Position{X: theme.Padding(), Y: 0})
        r.valueLabel.Resize(s.SubtractWidthHeight(0, 2*theme.Padding()))
        r.valueLabel.Move(fyne.Position{X: -theme.Padding(), Y: theme.Padding()})
        r.background.Resize(s)
}</span>

func (r *FieldRenderer) MinSize() fyne.Size <span class="cov0" title="0">{
        return fyne.NewSize(r.field.minWidth+2*theme.Padding(), r.valueLabel.MinSize().Height-theme.Padding())
}</span>

func (r *FieldRenderer) Objects() []fyne.CanvasObject <span class="cov0" title="0">{
        return []fyne.CanvasObject{r.background, r.valueLabel, r.nameText}
}</span>

func (r *FieldRenderer) Destroy() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package widgets

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
)

type Group struct {
        widget.BaseWidget
        name    string
        objects []fyne.CanvasObject
}

type GroupRenderer struct {
        group    *Group
        nameText *canvas.Text
        column   *fyne.Container
}

func NewGroup(name string, objects ...fyne.CanvasObject) *Group <span class="cov0" title="0">{
        group := &amp;Group{
                name:    name,
                objects: objects,
        }
        group.ExtendBaseWidget(group)
        return group
}</span>

func (g *Group) CreateRenderer() fyne.WidgetRenderer <span class="cov0" title="0">{
        nameText := canvas.NewText(g.name, theme.Color(theme.ColorNameForeground))
        nameText.TextStyle.Bold = true
        nameText.TextSize = 14

        nameText.Move(fyne.NewPos(2*theme.Padding(), 0))

        column := container.New(layout.NewVBoxLayout(), g.objects...)
        column.Move(fyne.NewPos(theme.Padding(), 6*theme.Padding()))

        return &amp;GroupRenderer{
                group:    g,
                nameText: nameText,
                column:   column,
        }
}</span>

func (r *GroupRenderer) Refresh() <span class="cov0" title="0">{
        r.column.Refresh()
        r.nameText.Refresh()
}</span>

func (r *GroupRenderer) Layout(s fyne.Size) <span class="cov0" title="0">{
        r.column.Move(fyne.Position{X: theme.Padding(), Y: 6 * theme.Padding()})
        r.column.Layout.Layout(r.group.objects, s.SubtractWidthHeight(2*theme.Padding(), 0))
}</span>

func (r *GroupRenderer) MinSize() fyne.Size <span class="cov0" title="0">{
        return fyne.NewSize(r.column.MinSize().Width+2*theme.Padding(), r.column.MinSize().Height+10*theme.Padding())
}</span>

func (r *GroupRenderer) Objects() []fyne.CanvasObject <span class="cov0" title="0">{
        return []fyne.CanvasObject{r.column, r.nameText}
}</span>

func (r *GroupRenderer) Destroy() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package widgets

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
)

type Spacer struct {
        widget.BaseWidget
        minWidth float32
}

type SpacerRenderer struct {
        spacer *Spacer
}

func NewSpacer() *Spacer <span class="cov0" title="0">{
        spacer := &amp;Spacer{}
        spacer.ExtendBaseWidget(spacer)
        return spacer
}</span>

func (s *Spacer) SetMinWidth(width float32) <span class="cov0" title="0">{
        if width &lt; 0 </span><span class="cov0" title="0">{
                width = 0
        }</span>

        <span class="cov0" title="0">s.minWidth = width</span>
}

func (s *Spacer) CreateRenderer() fyne.WidgetRenderer <span class="cov0" title="0">{
        return &amp;SpacerRenderer{
                spacer: s,
        }
}</span>

func (r *SpacerRenderer) Refresh() {<span class="cov0" title="0">}</span>

func (r *SpacerRenderer) Layout(s fyne.Size) {<span class="cov0" title="0">}</span>

func (r *SpacerRenderer) MinSize() fyne.Size <span class="cov0" title="0">{
        width := r.spacer.minWidth

        if r.spacer.minWidth == 0 </span><span class="cov0" title="0">{
                width = theme.Padding()
        }</span>

        <span class="cov0" title="0">return fyne.NewSize(width, 5*theme.Padding())</span>
}

func (r *SpacerRenderer) Objects() []fyne.CanvasObject <span class="cov0" title="0">{
        return []fyne.CanvasObject{}
}</span>

func (r *SpacerRenderer) Destroy() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package widgets

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
)

type StartPage struct {
        widget.BaseWidget
        status      string
        explanation string
        err         bool
}

type StartPageRenderer struct {
        page            *StartPage
        statusText      *canvas.Text
        explanationText *canvas.Text
        container       *fyne.Container
}

func NewStartPage() *StartPage <span class="cov0" title="0">{
        statusBar := &amp;StartPage{
                status:      "",
                explanation: "",
                err:         false,
        }
        statusBar.ExtendBaseWidget(statusBar)
        return statusBar
}</span>

func (sb *StartPage) SetStatus(status, explanation string, err bool) <span class="cov0" title="0">{
        sb.status = status
        sb.explanation = explanation
        sb.err = err
}</span>

func (sb *StartPage) CreateRenderer() fyne.WidgetRenderer <span class="cov0" title="0">{
        statusText := canvas.NewText(sb.status, theme.Color(theme.ColorNameForeground))
        statusText.TextSize = 16
        statusText.Color = theme.Color(theme.ColorNameError)

        explanationText := canvas.NewText(sb.status, theme.Color(theme.ColorNameForeground))
        explanationText.TextSize = 11
        explanationText.Color = theme.Color(theme.ColorNameForeground)

        box := container.New(layout.NewVBoxLayout(), statusText, explanationText)
        container := container.New(layout.NewCenterLayout(), box)

        return &amp;StartPageRenderer{
                page:            sb,
                statusText:      statusText,
                explanationText: explanationText,
                container:       container,
        }
}</span>

func (r *StartPageRenderer) Refresh() <span class="cov0" title="0">{
        r.statusText.Text = r.page.status
        r.explanationText.Text = r.page.explanation

        if r.page.err </span><span class="cov0" title="0">{
                r.statusText.Color = theme.Color(theme.ColorNameError)
        }</span> else<span class="cov0" title="0"> {
                r.statusText.Color = theme.Color(theme.ColorNameForeground)
        }</span>

        <span class="cov0" title="0">r.statusText.Refresh()
        r.explanationText.Refresh()</span>
}

func (r *StartPageRenderer) Layout(s fyne.Size) <span class="cov0" title="0">{
        r.container.Resize(s)
}</span>

func (r *StartPageRenderer) MinSize() fyne.Size <span class="cov0" title="0">{
        return fyne.NewSize(500, 300)
}</span>

func (r *StartPageRenderer) Objects() []fyne.CanvasObject <span class="cov0" title="0">{
        return []fyne.CanvasObject{r.container}
}</span>

func (r *StartPageRenderer) Destroy() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package widgets

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/canvas"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
)

type StatusBar struct {
        widget.BaseWidget
        status string
        err    bool
}

type StatusBarRenderer struct {
        bar        *StatusBar
        statusText *canvas.Text
}

func NewStatusBar() *StatusBar <span class="cov0" title="0">{
        statusBar := &amp;StatusBar{
                status: "",
                err:    true,
        }
        statusBar.ExtendBaseWidget(statusBar)
        return statusBar
}</span>

func (sb *StatusBar) SetStatus(status string, err bool) <span class="cov0" title="0">{
        sb.status = status
        sb.err = err
}</span>

func (sb *StatusBar) GetStatus() string <span class="cov0" title="0">{
        return sb.status
}</span>

func (sb *StatusBar) CreateRenderer() fyne.WidgetRenderer <span class="cov0" title="0">{
        statusText := canvas.NewText(sb.status, theme.Color(theme.ColorNameForeground))
        statusText.TextSize = 11
        statusText.Color = theme.Color(theme.ColorNameError)

        return &amp;StatusBarRenderer{
                bar:        sb,
                statusText: statusText,
        }
}</span>

func (r *StatusBarRenderer) Refresh() <span class="cov0" title="0">{
        r.statusText.Text = r.bar.status

        if r.bar.err </span><span class="cov0" title="0">{
                r.statusText.Color = theme.Color(theme.ColorNameError)
        }</span> else<span class="cov0" title="0"> {
                r.statusText.Color = theme.Color(theme.ColorNameForeground)
        }</span>

        <span class="cov0" title="0">r.statusText.Refresh()</span>
}

func (r *StatusBarRenderer) Layout(s fyne.Size) <span class="cov0" title="0">{
        r.statusText.Move(fyne.Position{X: theme.Padding(), Y: 2 * theme.Padding()})
}</span>

func (r *StatusBarRenderer) MinSize() fyne.Size <span class="cov0" title="0">{
        ts1 := fyne.MeasureText(r.statusText.Text, r.statusText.TextSize, r.statusText.TextStyle)
        return fyne.NewSize(ts1.Width+theme.Padding(), 2*ts1.Height)
}</span>

func (r *StatusBarRenderer) Objects() []fyne.CanvasObject <span class="cov0" title="0">{
        return []fyne.CanvasObject{r.statusText}
}</span>

func (r *StatusBarRenderer) Destroy() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package widgets

import (
        "fyne.io/fyne/v2"
        "fyne.io/fyne/v2/container"
        "fyne.io/fyne/v2/layout"
        "fyne.io/fyne/v2/theme"
        "fyne.io/fyne/v2/widget"
        "github.com/ubavic/bas-celik/v2/internal/gui/translation"
)

type Toolbar struct {
        widget.BaseWidget
        readers           []string
        onOpenAbout       func()
        onOpenPreferences func()
        onReaderChange    func(string)
        selectedReader    string
        showReaders       bool
}

type ToolbarRenderer struct {
        toolbar           *Toolbar
        aboutButton       *widget.Button
        preferencesButton *widget.Button
        container         *fyne.Container
        readersLabel      *widget.Label
        readersSelect     *widget.Select
}

func NewToolbar(onOpenAbout, onOpenPreferences func(), showReaders bool) *Toolbar <span class="cov0" title="0">{
        toolbar := &amp;Toolbar{
                readers:           nil,
                onOpenAbout:       onOpenAbout,
                onOpenPreferences: onOpenPreferences,
                showReaders:       showReaders,
        }

        toolbar.ExtendBaseWidget(toolbar)
        return toolbar
}</span>

func (t *Toolbar) HookReaderChange(hook func(string)) <span class="cov0" title="0">{
        t.onReaderChange = hook
}</span>

func (t *Toolbar) CreateRenderer() fyne.WidgetRenderer <span class="cov0" title="0">{
        label := widget.NewLabel(translation.Translate("ui.reader"))

        onChange := func(reader string) </span><span class="cov0" title="0">{
                if t.onReaderChange != nil </span><span class="cov0" title="0">{
                        t.onReaderChange(reader)
                }</span>
        }

        <span class="cov0" title="0">readersSelect := widget.NewSelect(t.readers, onChange)

        preferencesButton := widget.NewButtonWithIcon("", theme.SettingsIcon(), t.onOpenPreferences)
        preferencesButton.Importance = widget.LowImportance

        aboutButton := widget.NewButtonWithIcon("", theme.InfoIcon(), t.onOpenAbout)
        aboutButton.Importance = widget.LowImportance

        var horizontalContainer *fyne.Container
        if t.showReaders </span><span class="cov0" title="0">{
                horizontalContainer = container.New(layout.NewHBoxLayout(), label, readersSelect, layout.NewSpacer(), preferencesButton, aboutButton)
        }</span> else<span class="cov0" title="0"> {
                horizontalContainer = container.New(layout.NewHBoxLayout(), layout.NewSpacer(), preferencesButton, aboutButton)
        }</span>

        <span class="cov0" title="0">return &amp;ToolbarRenderer{
                toolbar:           t,
                aboutButton:       aboutButton,
                preferencesButton: preferencesButton,
                container:         horizontalContainer,
                readersLabel:      label,
                readersSelect:     readersSelect,
        }</span>
}

func (r *ToolbarRenderer) Refresh() <span class="cov0" title="0">{
        if r.toolbar.showReaders </span><span class="cov0" title="0">{
                r.readersSelect.SetOptions(r.toolbar.readers)
                r.readersSelect.Selected = r.toolbar.selectedReader

                if len(r.toolbar.readers) &lt;= 1 </span><span class="cov0" title="0">{
                        r.readersSelect.Disable()
                }</span> else<span class="cov0" title="0"> {
                        r.readersSelect.Enable()
                }</span>

                <span class="cov0" title="0">r.readersSelect.Refresh()</span>
        }

        <span class="cov0" title="0">r.aboutButton.Refresh()</span>
}

func (r *ToolbarRenderer) Layout(s fyne.Size) <span class="cov0" title="0">{
        availableWidth := s.Width
        availableWidth -= r.aboutButton.Size().Width
        availableWidth -= r.preferencesButton.MinSize().Width
        if r.toolbar.showReaders </span><span class="cov0" title="0">{
                availableWidth -= r.readersLabel.MinSize().Width
        }</span>
        <span class="cov0" title="0">availableWidth -= 2 * theme.InnerPadding()
        r.container.Resize(s)
        r.readersSelect.Resize(fyne.Size{Width: availableWidth, Height: s.Height})</span>
}

func (r *ToolbarRenderer) MinSize() fyne.Size <span class="cov0" title="0">{
        return r.container.MinSize()
}</span>

func (r *ToolbarRenderer) Objects() []fyne.CanvasObject <span class="cov0" title="0">{
        objects := []fyne.CanvasObject{r.aboutButton, r.preferencesButton, r.container}

        if r.toolbar.showReaders </span><span class="cov0" title="0">{
                objects = append(objects, r.readersSelect)
        }</span>

        <span class="cov0" title="0">return objects</span>
}

func (r *ToolbarRenderer) Destroy() {<span class="cov0" title="0">}</span>

func (r *Toolbar) SetReaders(readers []string, selectedReader string) <span class="cov0" title="0">{
        r.readers = make([]string, len(readers))
        copy(r.readers, readers)

        r.selectedReader = selectedReader

        r.Refresh()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package logger

import (
        "io"
        "log"
)

func init() <span class="cov0" title="0">{
        log.SetFlags(log.LstdFlags | log.Lmicroseconds)
}</span>

func DisableLog() <span class="cov0" title="0">{
        log.SetOutput(io.Discard)
}</span>

func Error(err error) <span class="cov0" title="0">{
        log.Println("ERROR", err.Error())
}</span>

func Info(message string) <span class="cov0" title="0">{
        log.Println("INFO", message)
}</span>

func Debug(message string) <span class="cov0" title="0">{
        log.Println("DEBUG", message)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package internal

import (
        "embed"
        "errors"
        "fmt"
        "os"

        "github.com/ebfe/scard"
        "github.com/ubavic/bas-celik/v2/card"
        "github.com/ubavic/bas-celik/v2/document"
)

type LaunchConfig struct {
        PdfPath               string
        JsonPath              string
        ExcelPath             string
        Verbose               bool
        GetValidUntilFromRfzo bool
        Reader                uint
        EmbedDirectory        embed.FS
}

func readAndSave(cfg LaunchConfig) error <span class="cov0" title="0">{
        ctx, err := scard.EstablishContext()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("establishing context: %w", err)
        }</span>

        <span class="cov0" title="0">defer ctx.Release()

        if len(cfg.PdfPath) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := os.Stat(cfg.PdfPath); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return fmt.Errorf("opening file %s: %w", cfg.PdfPath, err)
                }</span>
        }

        <span class="cov0" title="0">if len(cfg.JsonPath) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := os.Stat(cfg.JsonPath); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return fmt.Errorf("opening file %s: %w", cfg.JsonPath, err)
                }</span>
        }

        <span class="cov0" title="0">if len(cfg.ExcelPath) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := os.Stat(cfg.ExcelPath); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return fmt.Errorf("opening file %s: %w", cfg.ExcelPath, err)
                }</span>
        }

        <span class="cov0" title="0">readersNames, err := ctx.ListReaders()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("listing readers: %w", err)
        }</span>

        <span class="cov0" title="0">if len(readersNames) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no reader found")
        }</span>

        <span class="cov0" title="0">if cfg.Reader &gt;= uint(len(readersNames)) </span><span class="cov0" title="0">{
                return fmt.Errorf("only %d readers found", len(readersNames))
        }</span>

        <span class="cov0" title="0">sCard, err := ctx.Connect(readersNames[cfg.Reader], scard.ShareShared, scard.ProtocolAny)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connecting reader %s: %w", readersNames[cfg.Reader], err)
        }</span>

        <span class="cov0" title="0">defer sCard.Disconnect(scard.LeaveCard)

        cardDoc, err := card.DetectCardDocument(sCard)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("detecting card type: %w", err)
        }</span>

        <span class="cov0" title="0">err = cardDoc.InitCard()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initializing card: %w", err)
        }</span>

        <span class="cov0" title="0">err = cardDoc.ReadCard()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading card: %w", err)
        }</span>

        <span class="cov0" title="0">doc, err := cardDoc.GetDocument()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting document: %w", err)
        }</span>

        <span class="cov0" title="0">switch doc := doc.(type) </span>{
        case *document.MedicalDocument:<span class="cov0" title="0">
                if cfg.GetValidUntilFromRfzo </span><span class="cov0" title="0">{
                        err := doc.UpdateValidUntilDateFromRfzo()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("updating `ValidUntil` date: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(cfg.PdfPath) &gt; 0 </span><span class="cov0" title="0">{
                pdf, _, err := doc.BuildPdf()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generating pdf: %w", err)
                }</span>

                <span class="cov0" title="0">err = os.WriteFile(cfg.PdfPath, pdf, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("writing file %s: %w", cfg.PdfPath, err)
                }</span>
        }

        <span class="cov0" title="0">if len(cfg.JsonPath) &gt; 0 </span><span class="cov0" title="0">{
                json, err := doc.BuildJson()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generating json: %w", err)
                }</span>

                <span class="cov0" title="0">err = os.WriteFile(cfg.JsonPath, json, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("writing file %s: %w", cfg.JsonPath, err)
                }</span>
        }

        <span class="cov0" title="0">if len(cfg.ExcelPath) &gt; 0 </span><span class="cov0" title="0">{
                excel, _, err := doc.BuildExcel()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generating json: %w", err)
                }</span>

                <span class="cov0" title="0">err = os.WriteFile(cfg.ExcelPath, excel, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("writing file %s: %w", cfg.ExcelPath, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">//go:build !cli

package internal

import (
        "github.com/ubavic/bas-celik/v2/internal/gui"
        "github.com/ubavic/bas-celik/v2/internal/gui/icon"
        "github.com/ubavic/bas-celik/v2/internal/gui/translation"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func Run(cfg LaunchConfig) error <span class="cov0" title="0">{
        if len(cfg.PdfPath) == 0 &amp;&amp; len(cfg.JsonPath) == 0 &amp;&amp; len(cfg.ExcelPath) == 0 </span><span class="cov0" title="0">{
                err := translation.SetTranslations(cfg.EmbedDirectory)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = icon.LoadIcons(cfg.EmbedDirectory)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">gui.StartGui(version)
                return nil</span>
        }

        <span class="cov0" title="0">logger.Info("output file detected")
        return readAndSave(cfg)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package pkcs11

import (
        "crypto/x509"
        "errors"
        "fmt"
        "log"

        "github.com/miekg/pkcs11"
)

type NamedCert struct {
        Id          []byte
        Certificate *x509.Certificate
}

// wrapper around pkcs11.SessionHandle
// caches module certificates
type PkcsModuleSession struct {
        context *pkcs11.Ctx
        session pkcs11.SessionHandle
        certs   []NamedCert
}

// wrapper around pkcs11.Ctx
// it is used only for reference counting
type pkcsModuleCtx struct {
        context  *pkcs11.Ctx
        refCount uint
}

var gModuleContexts map[string]pkcsModuleCtx

func init() <span class="cov0" title="0">{
        gModuleContexts = make(map[string]pkcsModuleCtx)
}</span>

func NewPkcsExternalModule(modulePath string) (PkcsModuleSession, error) <span class="cov0" title="0">{
        mc, ok := gModuleContexts[modulePath]
        if !ok </span><span class="cov0" title="0">{
                pkcsCtx := pkcs11.New(modulePath)

                err := pkcsCtx.Initialize()
                if err != nil </span><span class="cov0" title="0">{
                        return PkcsModuleSession{}, fmt.Errorf("failed to initialize PKCS#11: %w", err)
                }</span>

                <span class="cov0" title="0">mc = pkcsModuleCtx{context: pkcsCtx}</span>
        }

        <span class="cov0" title="0">mc.refCount += 1
        gModuleContexts[modulePath] = mc

        return PkcsModuleSession{context: mc.context}, nil</span>
}

func (pm *PkcsModuleSession) ListSlots() ([]uint, []string, error) <span class="cov0" title="0">{
        slots, err := pm.context.GetSlotList(true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get slot list: %w", err)
        }</span>

        <span class="cov0" title="0">slotIds := make([]uint, 0, len(slots))
        slotNames := make([]string, 0, len(slots))

        for _, slot := range slots </span><span class="cov0" title="0">{
                info, err := pm.context.GetSlotInfo(slot)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // some modules (looking at you NetSet) don't properly set SlotInfo flags
                // therefore this should be more reliable way to check ig slot has token
                <span class="cov0" title="0">_, err = pm.context.GetTokenInfo(slot)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">slotIds = append(slotIds, slot)
                slotNames = append(slotNames, info.SlotDescription)</span>
        }

        <span class="cov0" title="0">return slotIds, slotNames, nil</span>
}

func (pm *PkcsModuleSession) OpenSessionAndLogin(pin string, slotId int) error <span class="cov0" title="0">{
        if slotId &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid slot id: %d", slotId)
        }</span>

        <span class="cov0" title="0">session, err := pm.context.OpenSession(uint(slotId), pkcs11.CKF_SERIAL_SESSION|pkcs11.CKF_RW_SESSION)
        if err != nil </span><span class="cov0" title="0">{
                pm.context.Destroy()
                return fmt.Errorf("failed to open PKCS#11 session: %w", err)
        }</span>

        <span class="cov0" title="0">err = pm.context.Login(session, pkcs11.CKU_USER, pin)
        if err != nil </span><span class="cov0" title="0">{
                pm.context.CloseSession(session)
                pm.context.Destroy()
                return fmt.Errorf("failed to login to smart card: %w", err)
        }</span>

        <span class="cov0" title="0">pm.session = session

        return nil</span>
}

func (pm *PkcsModuleSession) getRawCertificates() ([][]byte, [][]byte, error) <span class="cov0" title="0">{
        searchTemplate := []*pkcs11.Attribute{
                pkcs11.NewAttribute(pkcs11.CKA_CLASS, pkcs11.CKO_CERTIFICATE),
        }

        getTemplate := []*pkcs11.Attribute{
                pkcs11.NewAttribute(pkcs11.CKA_ID, nil),
                pkcs11.NewAttribute(pkcs11.CKA_VALUE, nil),
        }

        err := pm.context.FindObjectsInit(pm.session, searchTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to initialize object search: %w", err)
        }</span>

        <span class="cov0" title="0">objects, _, err := pm.context.FindObjects(pm.session, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to find objects: %w", err)
        }</span>

        <span class="cov0" title="0">err = pm.context.FindObjectsFinal(pm.session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to finalize object search: %w", err)
        }</span>

        <span class="cov0" title="0">ids := make([][]byte, 0, len(objects))
        certificates := make([][]byte, 0, len(objects))
        allErrors := []error{}
        for _, object := range objects </span><span class="cov0" title="0">{
                attr, err := pm.context.GetAttributeValue(pm.session, object, getTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, err)
                        continue</span>
                }

                <span class="cov0" title="0">ids = append(ids, attr[0].Value)
                certificates = append(certificates, attr[1].Value)</span>
        }

        <span class="cov0" title="0">return ids, certificates, errors.Join(allErrors...)</span>
}

func (pm *PkcsModuleSession) GetCertificates() ([]NamedCert, error) <span class="cov0" title="0">{
        if len(pm.certs) &gt; 0 </span><span class="cov0" title="0">{
                return pm.certs, nil
        }</span>

        <span class="cov0" title="0">ids, rawCertificates, err := pm.getRawCertificates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pm.certs = []NamedCert{}
        allErrors := []error{}
        for i, rawCertificate := range rawCertificates </span><span class="cov0" title="0">{
                cert, err := x509.ParseCertificate(rawCertificate)
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, err)
                        continue</span>
                }

                <span class="cov0" title="0">pm.certs = append(pm.certs, NamedCert{Certificate: cert, Id: ids[i]})</span>
        }

        <span class="cov0" title="0">return pm.certs, errors.Join(allErrors...)</span>
}

func (pm *PkcsModuleSession) CloseSession() error <span class="cov0" title="0">{
        err1 := pm.context.Logout(pm.session)
        err2 := pm.context.CloseSession(pm.session)

        for modulePath, mc := range gModuleContexts </span><span class="cov0" title="0">{
                if mc.context == pm.context </span><span class="cov0" title="0">{
                        mc.refCount = mc.refCount - 1

                        if mc.refCount &gt; 0 </span><span class="cov0" title="0">{
                                gModuleContexts[modulePath] = mc
                        }</span> else<span class="cov0" title="0"> {
                                pm.context.Destroy()
                                delete(gModuleContexts, modulePath)
                        }</span>

                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">return errors.Join(err1, err2)</span>
}

func (pm *PkcsModuleSession) Sign(certId []byte, message []byte) ([]byte, error) <span class="cov0" title="0">{
        err := pm.context.FindObjectsInit(pm.session, []*pkcs11.Attribute{
                pkcs11.NewAttribute(pkcs11.CKA_CLASS, pkcs11.CKO_PRIVATE_KEY),
                pkcs11.NewAttribute(pkcs11.CKA_ID, certId),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize private key search: %v", err)
        }</span>

        <span class="cov0" title="0">objects, _, err := pm.context.FindObjects(pm.session, 1)
        if err != nil || len(objects) == 0 </span><span class="cov0" title="0">{
                log.Fatalf("Private key not found")
        }</span>
        <span class="cov0" title="0">pm.context.FindObjectsFinal(pm.session)

        mech := []*pkcs11.Mechanism{
                pkcs11.NewMechanism(pkcs11.CKM_SHA256_RSA_PKCS, nil),
        }

        err = pm.context.SignInit(pm.session, mech, objects[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sig, err := pm.context.Sign(pm.session, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package pkcs11

type CardVendor int

const (
        CardVendorHalcom = CardVendor(iota)
        CardVendorPosta
        CardVendorEsmart
        CardVendorMup
        CardVendorPks
)

func (cv CardVendor) String() string <span class="cov0" title="0">{
        switch cv </span>{
        case CardVendorHalcom:<span class="cov0" title="0">
                return "Halcom CA"</span>
        case CardVendorPosta:<span class="cov0" title="0">
                return "Sertifikaciono telo Pote"</span>
        case CardVendorEsmart:<span class="cov0" title="0">
                return "E-Smart Systems d.o.o. Beograd (ESS QCA)"</span>
        case CardVendorMup:<span class="cov0" title="0">
                return "Ministarstvo unutranjih poslova CA"</span>
        case CardVendorPks:<span class="cov0" title="0">
                return "Privredna komora Srbije CA"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func GetDefaultPath(cv CardVendor, os string) string <span class="cov0" title="0">{
        if os == "linux" </span><span class="cov0" title="0">{
                switch cv </span>{
                case CardVendorPosta:<span class="cov0" title="0">
                        return "/usr/lib/libaetpkss.so"</span>
                case CardVendorEsmart:<span class="cov0" title="0">
                        return "/usr/lib/libeToken.so"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }

        <span class="cov0" title="0">if os == "darwin" </span><span class="cov0" title="0">{
                switch cv </span>{
                case CardVendorPosta:<span class="cov0" title="0">
                        return "/Applications/tokenadmin.app/Contents/Frameworks/libaetpkss.dylib"</span>
                case CardVendorEsmart:<span class="cov0" title="0">
                        return "/Library/Frameworks/eToken.framework/Versions/A/libIDPrimePKCS11.dylib"</span>
                case CardVendorHalcom:<span class="cov0" title="0">
                        return "/Applications/Personal.app/Contents/Frameworks/libtokenapi.dylib"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }

        <span class="cov0" title="0">if os == "windows" </span><span class="cov0" title="0">{
                switch cv </span>{
                case CardVendorHalcom:<span class="cov0" title="0">
                        return "C:\\Program Files (x86)\\Personal\\bin64\\personal64.dll"</span>
                case CardVendorPosta:<span class="cov0" title="0">
                        return "C:\\Windows\\System32\\aetpkss1.dll"</span>
                case CardVendorEsmart:<span class="cov0" title="0">
                        return "C:\\Program Files\\SafeNet\\Authentication\\SAC\\x64\\IDPrimePKCS1164.dll"</span>
                case CardVendorMup:<span class="cov0" title="0">
                        return "C:\\Program Files\\TrustEdgeID\\netsetpkcs11_x64.dll"</span>
                case CardVendorPks:<span class="cov0" title="0">
                        return "C:\\Program Files\\TrustEdgeID\\netsetpkcs11_x64.dll"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package server

import (
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "time"

        "github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11"
)

type GetCertificatesInput struct {
        TerminalId int    `json:"terminalId"`
        Pin        string `json:"pin"`
}

type GetCertificatesPayload struct {
        Certificates []CertificateAlias `json:"certificates"`
}

type CertificateAlias struct {
        Alias string `json:"alias"`
        Name  string `json:"name"`
}

func (s *SmartBoxServer) handleGetCertificates(session *SmartboxSession, data []byte, w io.Writer) error <span class="cov0" title="0">{
        msg := Message[GetCertificatesInput]{}
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if session.module == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pkcs11 module not loaded")
        }</span>

        <span class="cov0" title="0">err := session.module.OpenSessionAndLogin(msg.Input.Pin, msg.Input.TerminalId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">certs, err := session.module.GetCertificates()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rsp := Response[GetCertificatesPayload]{
                Operation: operationGetCertificates,
                Payload: GetCertificatesPayload{
                        Certificates: GetCertificateAliases(GetValidCertificates(certs)),
                },
        }

        return json.NewEncoder(w).Encode(rsp)</span>
}

func GetValidCertificates(namedCerts []pkcs11.NamedCert) []pkcs11.NamedCert <span class="cov0" title="0">{
        now := time.Now()

        validNamedCertificates := make([]pkcs11.NamedCert, 0, len(namedCerts))
        for _, namedCert := range namedCerts </span><span class="cov0" title="0">{
                if now.Before(namedCert.Certificate.NotBefore) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if now.After(namedCert.Certificate.NotAfter) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">validNamedCertificates = append(validNamedCertificates, namedCert)</span>
        }

        <span class="cov0" title="0">return validNamedCertificates</span>
}

func GetCertificateAliases(namedCerts []pkcs11.NamedCert) []CertificateAlias <span class="cov0" title="0">{
        aliases := make([]CertificateAlias, 0, len(namedCerts))
        for _, namedCert := range namedCerts </span><span class="cov0" title="0">{
                alias := CertificateAlias{
                        Alias: hex.EncodeToString(namedCert.Id),
                        Name:  namedCert.Certificate.Subject.CommonName,
                }
                aliases = append(aliases, alias)
        }</span>

        <span class="cov0" title="0">return aliases</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "io"
)

type GetInfoInput struct {
        SbSession string `json:"sbSession"`
        Language  string `json:"language"`
        Host      string `json:"host"`
}

type GetInfoPayload struct {
        TerminalId    int    `json:"terminalId"`
        ProviderId    int    `json:"providerId"`
        CertificateId string `json:"certificateId"`
}

func (s *SmartBoxServer) handleGetInfo(sessionId *string, data []byte, w io.Writer) error <span class="cov0" title="0">{
        msg := Message[GetInfoInput]{}
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if msg.Input.SbSession == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid session id")
        }</span>

        <span class="cov0" title="0">session, ok := s.sessions[msg.Input.SbSession]
        if !ok </span><span class="cov0" title="0">{
                s.sessions[msg.Input.SbSession] = SmartboxSession{
                        id: msg.Input.SbSession,
                }
        }</span>

        <span class="cov0" title="0">*sessionId = msg.Input.SbSession

        rsp := Response[GetInfoPayload]{
                Operation: operationGetInfo,
                Payload: GetInfoPayload{
                        TerminalId:    session.terminalId,
                        ProviderId:    int(session.vendor),
                        CertificateId: session.certificateId,
                },
        }

        return json.NewEncoder(w).Encode(rsp)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package server

import (
        "encoding/json"
        "io"
)

type GetProvidersInput struct{}

type GetProvidersPayload struct {
        Providers []Provider `json:"providers"`
}

type Provider struct {
        Id   int    `json:"id"`
        Name string `json:"name"`
}

func (s *SmartBoxServer) handleGetProviders(data []byte, w io.Writer) error <span class="cov0" title="0">{
        msg := Message[GetProvidersInput]{}
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">providers := make([]Provider, 0, len(s.modulePaths))
        for _, module := range s.modulePaths </span><span class="cov0" title="0">{
                providers = append(providers, Provider{
                        Id:   int(module.Vendor),
                        Name: module.Vendor.String(),
                })
        }</span>

        <span class="cov0" title="0">rsp := Response[GetProvidersPayload]{
                Operation: operationGetProviders,
                Payload: GetProvidersPayload{
                        Providers: providers,
                },
        }

        return json.NewEncoder(w).Encode(rsp)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package server

import (
        "bytes"
        "crypto/sha256"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "slices"
        "strings"
)

const xmlHeader = `&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;`

type GetSignedXmlInput struct {
        Certificate CertificateAlias `json:"certificate"`
        Pin         string           `json:"pin"`
        Xml         string           `json:"xml"`
}

type GetSignedXmlPayload struct {
        Xml string `json:"xml"`
}

type envelopeReq struct {
        XMLName   xml.Name `xml:"envelopaEPrijave"`
        XMLNS     string   `xml:"xmlns:ns2,attr"`
        Timestamp string   `xml:"timestamp"`
}

type envelopeResp struct {
        XMLName   xml.Name   `xml:"ns2:envelopaEPrijave"`
        XMLNS     string     `xml:"xmlns:ns2,attr"`
        Timestamp string     `xml:"timestamp"`
        Signature *signature `xml:"signature,omitempty"`
}

type signature struct {
        XMLName        xml.Name
        Xmlns          string `xml:"xmlns,attr"`
        SignedInfo     signedInfo
        SignatureValue string
        KeyInfo        struct {
                X509Data struct {
                        X509Certificate  string
                        X509IssuerSerial struct {
                                X509IssuerName   string
                                X509SerialNumber string
                        }
                        X509SubjectName string
                }
        }
}

type signedInfo struct {
        XMLName                xml.Name
        Xmlns                  string `xml:"xmlns,attr,omitempty"`
        Ns2                    string `xml:"xmlns:ns2,attr,omitempty"`
        CanonicalizationMethod struct {
                Algorithm string `xml:",attr"`
        }
        SignatureMethod struct {
                Algorithm string `xml:",attr"`
        }
        Reference struct {
                Uri        string `xml:"URI,attr"`
                Transforms struct {
                        Transform struct {
                                Algorithm string `xml:",attr"`
                        }
                }
                DigestMethod struct {
                        Algorithm string `xml:",attr"`
                }
                DigestValue string
        }
}

func (s *SmartBoxServer) handleGetSignedXml(session *SmartboxSession, data []byte, w io.Writer) error <span class="cov0" title="0">{
        msg := Message[GetSignedXmlInput]{}
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if session.module == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pkcs11 module not loaded")
        }</span>

        <span class="cov0" title="0">certId, err := hex.DecodeString(msg.Input.Certificate.Alias)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">signXML, err := signRequest(session.module, certId, msg.Input.Xml)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rsp := Response[GetSignedXmlPayload]{
                Operation: operationGetCertificates,
                Payload: GetSignedXmlPayload{
                        Xml: base64.StdEncoding.EncodeToString(signXML),
                },
        }

        return json.NewEncoder(w).Encode(rsp)</span>
}

func signRequest(module PkcsModuleSession, id []byte, base64XmlRequest string) ([]byte, error) <span class="cov0" title="0">{
        namedCerts, err := module.GetCertificates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cert *x509.Certificate
        for _, namedCert := range namedCerts </span><span class="cov0" title="0">{
                if slices.Equal(namedCert.Id, id) </span><span class="cov0" title="0">{
                        cert = namedCert.Certificate
                }</span>
        }

        <span class="cov0" title="0">if cert == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("certificate %s not found", hex.EncodeToString(id))
        }</span>

        <span class="cov0" title="0">xmlString, err := base64.StdEncoding.DecodeString(base64XmlRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">a, _ := bytes.CutPrefix(xmlString, []byte(xmlHeader))

        hash := sha256.Sum256(a)
        hashBase64 := base64.StdEncoding.EncodeToString(hash[:])

        signedInfo := constructSignedInfo(hashBase64)
        timestamp, err := extractTimestamp(xmlString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">marshaled := signedInfo.marshal()

        signed, err := module.Sign(id, marshaled)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">module.CloseSession()

        envelope := constructResponse(cert, timestamp, signedInfo, signed)

        buf := bytes.Buffer{}
        buf.Write([]byte(xmlHeader))

        enc := xml.NewEncoder(&amp;buf)
        enc.Indent("", "")
        enc.Encode(envelope)

        return buf.Bytes(), nil</span>
}

func extractTimestamp(input []byte) (string, error) <span class="cov0" title="0">{
        var env envelopeReq
        err := xml.Unmarshal(input, &amp;env)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return env.Timestamp, nil</span>
}

func constructResponse(cert *x509.Certificate, timestamp string, signedInfo signedInfo, signatureValue []byte) envelopeResp <span class="cov0" title="0">{
        signatureValueBase64 := base64.StdEncoding.EncodeToString(signatureValue)

        signedInfo.Xmlns = ""
        signedInfo.Ns2 = ""

        signature := signatureXML(cert, signedInfo, signatureValueBase64)

        envelope := envelopeResp{
                XMLNS:     "urn:poreskauprava.gov.rs/zim",
                Timestamp: timestamp,
                Signature: &amp;signature,
        }

        return envelope
}</span>

func constructSignedInfo(digestValue string) signedInfo <span class="cov0" title="0">{
        signedInfo := signedInfo{}

        signedInfo.XMLName = xml.Name{Local: "SignedInfo"}
        signedInfo.Xmlns = "http://www.w3.org/2000/09/xmldsig#"
        signedInfo.Ns2 = "urn:poreskauprava.gov.rs/zim"
        signedInfo.CanonicalizationMethod.Algorithm = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315"
        signedInfo.SignatureMethod.Algorithm = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"
        signedInfo.Reference.DigestMethod.Algorithm = "http://www.w3.org/2001/04/xmlenc#sha256"
        signedInfo.Reference.DigestValue = digestValue
        signedInfo.Reference.Transforms.Transform.Algorithm = "http://www.w3.org/2000/09/xmldsig#enveloped-signature"

        return signedInfo
}</span>

func signatureXML(cert *x509.Certificate, signedInfo signedInfo, signatureValue string) signature <span class="cov0" title="0">{
        sig := signature{}
        sig.XMLName = xml.Name{Local: "Signature"}
        sig.Xmlns = "http://www.w3.org/2000/09/xmldsig#"

        sig.SignedInfo = signedInfo
        sig.SignatureValue = signatureValue
        sig.KeyInfo.X509Data.X509Certificate = base64.RawStdEncoding.EncodeToString(cert.Raw)
        sig.KeyInfo.X509Data.X509IssuerSerial.X509IssuerName = cert.Issuer.String()
        sig.KeyInfo.X509Data.X509IssuerSerial.X509SerialNumber = cert.SerialNumber.String()
        sig.KeyInfo.X509Data.X509SubjectName = formatSubject(cert.Subject)

        return sig
}</span>

func (s *signedInfo) marshal() []byte <span class="cov0" title="0">{
        buf := bytes.Buffer{}
        enc := xml.NewEncoder(&amp;buf)
        enc.Indent("", "")
        enc.Encode(s)

        return buf.Bytes()
}</span>

func formatSubject(subject pkix.Name) string <span class="cov0" title="0">{
        var serNo1, serNo2, givenName, surname, country string

        for _, name := range subject.Names </span><span class="cov0" title="0">{
                strB, ok := name.Value.(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if slices.Equal(name.Type, []int{2, 5, 4, 5}) </span><span class="cov0" title="0">{
                        if serNo1 == "" </span><span class="cov0" title="0">{
                                serNo1 = string(strB)
                        }</span> else<span class="cov0" title="0"> {
                                serNo2 = string(strB)
                        }</span>
                } else<span class="cov0" title="0"> if slices.Equal(name.Type, []int{2, 5, 4, 42}) </span><span class="cov0" title="0">{
                        givenName = string(strB)
                }</span> else<span class="cov0" title="0"> if slices.Equal(name.Type, []int{2, 5, 4, 4}) </span><span class="cov0" title="0">{
                        surname = string(strB)
                }</span>
        }

        <span class="cov0" title="0">if strings.Contains(serNo2, "PNORS") </span><span class="cov0" title="0">{
                serNo1, serNo2 = serNo2, serNo1
        }</span>

        <span class="cov0" title="0">if len(subject.Country) &gt; 0 </span><span class="cov0" title="0">{
                country = subject.Country[0]
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("CN=%s, GIVENNAME=%s, SURNAME=%s, SERIALNUMBER=%s, SERIALNUMBER=%s, C=%s",
                subject.CommonName,
                givenName,
                surname,
                serNo1,
                serNo2,
                country)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "io"
        "slices"

        "github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11"
)

type GetTerminalsInput struct {
        ProviderId stringOrInt `json:"providerId"`
}

type GetTerminalsPayload struct {
        Terminals []Terminal `json:"terminals"`
}

type Terminal struct {
        Id   string `json:"id"`
        Name string `json:"name"`
}

func (s *SmartBoxServer) handleGetTerminals(session *SmartboxSession, data []byte, w io.Writer) error <span class="cov0" title="0">{
        msg := Message[GetTerminalsInput]{}
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">providerID := msg.Input.ProviderId

        if providerID &lt; 0 || int(providerID) &gt; int(pkcs11.CardVendorPks) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid provider id")
        }</span>

        <span class="cov0" title="0">moduleIndex := slices.IndexFunc(s.modulePaths, func(m ModulePath) bool </span><span class="cov0" title="0">{
                return m.Vendor == pkcs11.CardVendor(providerID)
        }</span>)

        <span class="cov0" title="0">if moduleIndex &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("module not found")
        }</span>

        <span class="cov0" title="0">module, err := pkcs11.NewPkcsExternalModule(s.modulePaths[moduleIndex].Path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.vendor = pkcs11.CardVendor(providerID)
        session.module = &amp;module

        slotIds, slotNames, err := module.ListSlots()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">terminals := make([]Terminal, 0, len(slotIds))
        for i, id := range slotIds </span><span class="cov0" title="0">{
                terminals = append(terminals, Terminal{
                        Id:   fmt.Sprintf("%d", id),
                        Name: slotNames[i],
                })
        }</span>

        <span class="cov0" title="0">rsp := Response[GetTerminalsPayload]{
                Operation: operationGetTerminals,
                Payload: GetTerminalsPayload{
                        Terminals: terminals,
                },
        }

        return json.NewEncoder(w).Encode(rsp)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package server

import (
        "encoding/json"
        "io"
        "runtime"
)

func onOpen(w io.Writer) error <span class="cov0" title="0">{
        rsp := Response[OnOpenPayload]{
                Operation: onOpenEvent,
                Payload: OnOpenPayload{
                        AppName:    "SmartBox",
                        AppVersion: "2.0.0",
                        AppBuild:   1,
                        OsName:     runtime.GOOS,
                        OsVersion:  "1",
                        OsArch:     runtime.GOARCH,
                },
        }

        return json.NewEncoder(w).Encode(rsp)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/coder/websocket"
        "github.com/ubavic/bas-celik/v2/internal/logger"
)

type Message[I any] struct {
        Operation string `json:"operation"`
        Input     I
}

type Response[P any] struct {
        Operation string `json:"operation"`
        Status    int    `json:"status"`
        Payload   P      `json:"payload"`
}

type OnOpenPayload struct {
        AppName    string `json:"appName"`
        AppVersion string `json:"appVersion"`
        AppBuild   int    `json:"appBuild"`
        OsName     string `json:"osName"`
        OsVersion  string `json:"osVersion"`
        OsArch     string `json:"osArch"`
}

var onOpenEvent = "ON_OPEN_EVENT"
var operationGetInfo = "GET_INFO"
var operationGetProviders = "GET_PROVIDERS"
var operationGetTerminals = "GET_TERMINALS"
var operationGetCertificates = "GET_CERTIFICATES"
var operationGetSignedXml = "GET_SIGNED_XML"

type SmartBoxServer struct {
        sessions    map[string]SmartboxSession
        modulePaths []ModulePath
}

func (s *SmartBoxServer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := websocket.Accept(w, r, &amp;websocket.AcceptOptions{
                OriginPatterns: []string{"eporezi.purs.gov.rs"},
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">defer conn.CloseNow()

        err = s.smartBoxHandler(conn)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                logger.Error(err)
        }</span>
}

func (s *SmartBoxServer) smartBoxHandler(conn *websocket.Conn) error <span class="cov0" title="0">{
        ctx, cancelCtx := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancelCtx()

        w, err := conn.Writer(ctx, websocket.MessageText)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = onOpen(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">w.Close()

        sessionId := ""

        for </span><span class="cov0" title="0">{
                err = s.onMessage(&amp;sessionId, ctx, conn)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err)
                        break</span>
                }
        }

        <span class="cov0" title="0">return conn.CloseNow()</span>
}

func (s *SmartBoxServer) onMessage(sessionId *string, ctx context.Context, conn *websocket.Conn) error <span class="cov0" title="0">{
        _, data, err := conn.Read(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">msg := Message[any]{}
        json.Unmarshal(data, &amp;msg)

        logger.Debug(fmt.Sprintf("Received `%s` message. Session `%s`.", msg.Operation, *sessionId))

        w, err := conn.Writer(ctx, websocket.MessageText)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer w.Close()

        session, ok := s.sessions[*sessionId]
        if !ok &amp;&amp; msg.Operation != operationGetInfo </span><span class="cov0" title="0">{
                return fmt.Errorf("session not found")
        }</span>

        <span class="cov0" title="0">switch msg.Operation </span>{
        case operationGetInfo:<span class="cov0" title="0">
                err = s.handleGetInfo(sessionId, data, w)</span>
        case operationGetProviders:<span class="cov0" title="0">
                err = s.handleGetProviders(data, w)</span>
        case operationGetTerminals:<span class="cov0" title="0">
                err = s.handleGetTerminals(&amp;session, data, w)</span>
        case operationGetCertificates:<span class="cov0" title="0">
                err = s.handleGetCertificates(&amp;session, data, w)</span>
        case operationGetSignedXml:<span class="cov0" title="0">
                err = s.handleGetSignedXml(&amp;session, data, w)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unknown operation %s", msg.Operation)</span>
        }

        <span class="cov0" title="0">s.sessions[*sessionId] = session
        return err</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package server

import (
        "os"

        "github.com/ubavic/bas-celik/v2/internal/smartbox/pkcs11"
)

type PkcsModuleSession interface {
        ListSlots() ([]uint, []string, error)
        OpenSessionAndLogin(pin string, terminalIndex int) error
        GetCertificates() ([]pkcs11.NamedCert, error)
        Sign(certId []byte, message []byte) ([]byte, error)
        CloseSession() error
}

type SmartboxSession struct {
        id            string
        module        PkcsModuleSession
        terminalId    int
        vendor        pkcs11.CardVendor
        certificateId string
}

type ModulePath struct {
        Vendor pkcs11.CardVendor
        Path   string
}

func (s *SmartBoxServer) setModulePaths(paths []ModulePath) int <span class="cov0" title="0">{
        s.modulePaths = make([]ModulePath, 0, len(paths))

        for _, mPath := range paths </span><span class="cov0" title="0">{
                if mPath.Path == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fInfo, err := os.Stat(mPath.Path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if fInfo.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">s.modulePaths = append(s.modulePaths, mPath)</span>
        }

        <span class="cov0" title="0">return len(s.modulePaths)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package server

import (
        "fmt"
        "net"
        "net/http"
        "time"

        "github.com/ubavic/bas-celik/v2/internal/logger"
)

func StartServer(modulePaths []ModulePath) (string, error) <span class="cov0" title="0">{
        smartboxServer := SmartBoxServer{}
        smartboxServer.sessions = make(map[string]SmartboxSession)

        modules := smartboxServer.setModulePaths(modulePaths)
        if modules == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no valid pkcs11 path loaded")
        }</span>

        <span class="cov0" title="0">ports := []uint{17165, 20806, 65097}
        port := findAvailablePort(ports)
        if port == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no valid port available")
        }</span>

        <span class="cov0" title="0">l, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">s := &amp;http.Server{
                Handler:      &amp;smartboxServer,
                ReadTimeout:  time.Second * 10,
                WriteTimeout: time.Second * 10,
        }

        go func() </span><span class="cov0" title="0">{
                s.Serve(l)
        }</span>()

        <span class="cov0" title="0">logger.Info(fmt.Sprintf("Smartbox server listening on ws://%v", l.Addr()))

        return l.Addr().String(), nil</span>
}

func findAvailablePort(ports []uint) uint <span class="cov0" title="0">{
        for _, port := range ports </span><span class="cov0" title="0">{
                listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
                if err == nil </span><span class="cov0" title="0">{
                        listener.Close()
                        return port
                }</span>
        }

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "strconv"
)

type stringOrInt int

func (v *stringOrInt) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var intVal int
        err := json.Unmarshal(data, &amp;intVal)
        if err == nil </span><span class="cov0" title="0">{
                *v = stringOrInt(intVal)
                return nil
        }</span>

        <span class="cov0" title="0">var strVal string
        err = json.Unmarshal(data, &amp;strVal)
        if err == nil </span><span class="cov0" title="0">{
                intVal, err := strconv.Atoi(strVal)
                if err == nil </span><span class="cov0" title="0">{
                        *v = stringOrInt(intVal)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid value for stringOrInt: %s", string(data))</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package localization

import "strings"

func FormatYesNo(a bool, script Language) string <span class="cov8" title="1">{
        if script == SrLatin </span><span class="cov8" title="1">{
                if a </span><span class="cov8" title="1">{
                        return "Da"
                }</span> else<span class="cov8" title="1"> {
                        return "Ne"
                }</span>
        } else<span class="cov8" title="1"> if script == SrCyrillic </span><span class="cov8" title="1">{
                if a </span><span class="cov8" title="1">{
                        return ""
                }</span> else<span class="cov8" title="1"> {
                        return ""
                }</span>
        } else<span class="cov8" title="1"> {
                if a </span><span class="cov8" title="1">{
                        return "Yes"
                }</span> else<span class="cov8" title="1"> {
                        return "No"
                }</span>
        }
}

// Expects a pointer to a date in the format DDMMYYYY.
// Modifies, in place, date to format DD.MM.YYYY.
func FormatDate(in *string) <span class="cov8" title="1">{
        chars := strings.Split(*in, "")
        if len(chars) != 8 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if chars[4] == "0" </span><span class="cov8" title="1">{
                *in = "Nije dostupan"
                return
        }</span>
        <span class="cov8" title="1">*in = chars[0] + chars[1] + "." + chars[2] + chars[3] + "." + chars[4] + chars[5] + chars[6] + chars[7] + "."</span>
}

// Expects a pointer to a date in the format YYYYMMDD.
// Modifies, in place, date to format DD.MM.YYYY.
func FormatDateYMD(in *string) <span class="cov8" title="1">{
        chars := strings.Split(*in, "")
        if len(chars) != 8 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">*in = chars[6] + chars[7] + "." + chars[4] + chars[5] + "." + chars[0] + chars[1] + chars[2] + chars[3]</span>
}

// Joins list of strings into a single string
// separating them with a comma and a space.
// Empty strings are skipped.
func JoinWithComma(strs ...string) string <span class="cov8" title="1">{
        var nonemptyStrings []string
        for _, str := range strs </span><span class="cov8" title="1">{
                if str != "" </span><span class="cov8" title="1">{
                        nonemptyStrings = append(nonemptyStrings, str)
                }</span>
        }

        <span class="cov8" title="1">return strings.Join(nonemptyStrings, ", ")</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package localization

var cyrillic = []rune{
        '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
        '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
}

var latin = []string{
        "A", "B", "V", "G", "D", "", "E", "", "Z", "I", "J", "K", "L", "Lj", "M", "N", "Nj", "O", "P", "R", "S", "T", "", "U", "F", "H", "C", "", "D", "",
        "a", "b", "v", "g", "d", "", "e", "", "z", "i", "j", "k", "l", "lj", "m", "n", "nj", "o", "p", "r", "s", "t", "", "u", "f", "h", "c", "", "d", "",
}

func CyrillicToLatin(str string) string <span class="cov8" title="1">{
        out := ""

        for _, r := range str </span><span class="cov8" title="1">{
                index := indexOfCyrillic(r)
                if index &gt;= 0 </span><span class="cov8" title="1">{
                        out += latin[index]
                }</span> else<span class="cov8" title="1"> {
                        out += string(r)
                }</span>
        }

        <span class="cov8" title="1">return out</span>
}

func indexOfCyrillic(r rune) int <span class="cov8" title="1">{
        for i, v := range cyrillic </span><span class="cov8" title="1">{
                if v == r </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package main

import (
        "os"

        "github.com/ubavic/bas-celik/v2/document"
        "github.com/ubavic/bas-celik/v2/internal"
        "github.com/ubavic/bas-celik/v2/internal/logger"

        "embed"
        "fmt"
)

//go:embed assets/version
var version string

//go:embed embed/*
var embedFS embed.FS

func main() <span class="cov0" title="0">{
        internal.SetVersion(version)

        cfg, exit := internal.ProcessFlags()
        if exit </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if !cfg.Verbose </span><span class="cov0" title="0">{
                logger.DisableLog()
        }</span>

        <span class="cov0" title="0">cfg.EmbedDirectory = embedFS

        err := configDocumentPackage()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = internal.Run(cfg)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error:", err)
                os.Exit(2)
        }</span>
}

func configDocumentPackage() error <span class="cov0" title="0">{
        documentConfig := document.DocumentConfig{}
        var err error

        documentConfig.FontRegular, err = embedFS.ReadFile("embed/liberationSansRegular.ttf")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading font: %w", err)
        }</span>

        <span class="cov0" title="0">documentConfig.FontBold, err = embedFS.ReadFile("embed/liberationSansBold.ttf")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading font: %w", err)
        }</span>

        <span class="cov0" title="0">documentConfig.RfzoLogo, err = embedFS.ReadFile("embed/rfzo.png")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading font: %w", err)
        }</span>

        <span class="cov0" title="0">err = document.Configure(documentConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("setup error: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
